<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="GIn">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://Gin-lxy.github.io/2023/11/15/数据结构复习/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Chapter 1 绪论1. 基本概念1.数据  被计算机加工处理的对象。2.数据元素（记录、表目）  数据的基本单位，是数据集合中的一个个体。    一个数据元素可由若干个数据项组成3.数据对象  是性质相同的数据元素的集合，是数据的一个子集。4.数据结构  具有结构的数据元素的集合。它包括数据元素的逻辑结构、存储结构和相适应的运算。 逻辑结构数据元素之间的逻辑关系，与计算机无关。可用一个二元组">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习">
<meta property="og:url" content="https://gin-lxy.github.io/2023/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Chapter 1 绪论1. 基本概念1.数据  被计算机加工处理的对象。2.数据元素（记录、表目）  数据的基本单位，是数据集合中的一个个体。    一个数据元素可由若干个数据项组成3.数据对象  是性质相同的数据元素的集合，是数据的一个子集。4.数据结构  具有结构的数据元素的集合。它包括数据元素的逻辑结构、存储结构和相适应的运算。 逻辑结构数据元素之间的逻辑关系，与计算机无关。可用一个二元组">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185653.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185759%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185809.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204806.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204827.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%9B%BE%E7%89%871%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%9B%BE%E7%89%872%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20211057.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210226145948307.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210226150421261.png">
<meta property="article:published_time" content="2023-11-15T13:48:20.000Z">
<meta property="article:modified_time" content="2024-01-04T15:42:32.930Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="课内">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/avatar.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
    <meta name="theme-color" content="#8f7ff4">
    <link rel="shortcut icon" href="/images/avatar.jpg">
    <!--- Page Info-->
    
    <title>
        
            数据结构复习 -
        
        GIn&#39;s notebook
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"gin-lxy.github.io","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"�Ƽ��Ķ�","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#8f7ff4","secondary":"#8587a7"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"GIn's notebook","subtitle":{"text":["The world is my oyster."],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.5.0","navbar":{"auto_hide":false,"color":{"left":"#8f7ff4","right":"#8587a7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                GIn&#39;s notebook
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title">
            
                <h1 class="article-title-regular">数据结构复习</h1>
            
            </div>
            
                    
        
        
            <div class="article-header flex flex-row gap-2 items-center">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">GIn</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-11-15 21:48:20</span>
        <span class="mobile">2023-11-15 21:48:20</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-01-04 23:42:32</span>
            <span class="mobile">2024-01-04 23:42:32</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/blog/">blog</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E8%AF%BE%E5%86%85/">课内</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body">
            <h1 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 绪论"></a>Chapter 1 绪论</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>1.数据  被计算机加工处理的对象。<br>2.数据元素（记录、表目）  数据的基本单位，是数据集合中的一个个体。<br>    一个数据元素可由若干个数据项组成<br>3.数据对象  是性质相同的数据元素的集合，是数据的一个子集。<br>4.数据结构  具有结构的数据元素的集合。它包括数据元素的逻辑结构、存储结构和相适应的运算。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据元素之间的逻辑关系，与计算机无关。<br>可用一个二元组表示：Data_Structure &#x3D; (D,R)<br>    D—数据元素的有穷集合，R—D上关系的有穷集合。</p>
<h4 id="四种基本的逻辑结构"><a href="#四种基本的逻辑结构" class="headerlink" title="四种基本的逻辑结构"></a>四种基本的逻辑结构</h4><p>(1)集合结构  数据元素除了“属于同一集合”的联系之外，没有其它的关系。<br>(2)线性结构  数据元素之间存在一对一的关系。<br>(3)树型结构  数据元素之间存在一对多的关系。<br>(4)图状结构或网状结构  数据元素之间存在多对多的关系。</p>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构)"></a>存储结构(物理结构)</h3><pre><code>指数据的逻辑结构在计算机存储器中的映象表示。
</code></pre>
<p>1.数据元素的映象<br>     用二进制位(bit)的位串表示数据元素。<br>           每个数据元素的映象称为结点<br>           每个数据项的映象称为数据域<br>关系的映象<br>2.两种基本方法及其组合使用。<br>     顺序映象：以相对的存储位置表示关系<br>     链式映象：以附加信息(指针)表示关系<br>在不同的编程环境下，存储结构有不同的描述方式。用高级程序语言编程时，通常可用其提供的数据类型描述。</p>
<h4 id="数据存储方式的四种常用结构"><a href="#数据存储方式的四种常用结构" class="headerlink" title="数据存储方式的四种常用结构"></a>数据存储方式的四种常用结构</h4><p>(1)顺序存储：数据元素依次放在连续的存储单元中。<br>(2)链式存储：在存储结点中增加若干指针域，记录后继或者相关结点的地址（指针）。<br>(3)索引存储：将数据元素分为若干子表，子表的开始位置存放在索引表中。<br>(4)散列存储：根据数据元素的关键字值，由散列函数计算出存储地址。LOC(ai)&#x3D;H(key)</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>运算（操作）：在数据逻辑结构上定义的一组数据被使用的方式，其具体实现要在存储结构上进行。</p>
<p>几种常用的运算有：<br>    (1)建立数据结构              (6)检索*<br>    (2)清除数据结构              (7)更新<br>    (3)插入数据元素              (8)判空和判满*<br>    (4)删除数据元素              (9)求长*<br>    (5)排序</p>
<pre><code>操作为引用型操作，即数据值不发生变化；其它为加工型操作。
</code></pre>
<h2 id="算法的描述和分析"><a href="#算法的描述和分析" class="headerlink" title="算法的描述和分析"></a>算法的描述和分析</h2><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><pre><code>建立在数据结构基础上的、求解问题的一系列确切的步骤。
</code></pre>
<p>一个算法必须满足以下五个重要特性</p>
<ul>
<li>有穷性：对任何合法输入执行有穷步后能结束。</li>
<li>确定性：每条指令必须有确切的含义。</li>
<li>可行性：算法的每一条指令均能执行。</li>
<li>输入：有零个或多个输入。</li>
<li>输出：有一个或多个输出。</li>
</ul>
<p>评价算法优劣的基本标准:正确性 可读性 健壮性 高效性</p>
<p>算法效率的度量: 时间复杂度 空间复杂度</p>
<h3 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h3><h4 id="选择描述工具的原则"><a href="#选择描述工具的原则" class="headerlink" title="选择描述工具的原则"></a>选择描述工具的原则</h4><p>不依赖于具体计算机与具体程序设计语言的一种形式化语言，可用于描述或表达算法思想。<br>       本课程采用 C 语言<br>         特点  它描述的算法自然易懂，具有较好的可移植性。</p>
<h4 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h4><h5 id="1）时间复杂度"><a href="#1）时间复杂度" class="headerlink" title="1）时间复杂度"></a>1）时间复杂度</h5><p>算法的消耗时间：算法中每条语句执行时间之和。<br>时间复杂度：算法中各语句的频度之和T(n)。<br>                     频度—语句的执行次数；<br>                      n—问题的规模，一般为数据的输入量<br>渐近时间复杂度：当问题的规模n趋于无穷大时，T(n)的数量级(阶)。记为T(n)&#x3D;O( f(n) )。<br>     O的严格含义— 存在正的常数c和n0，使得当n$\ge$n0时, 0 $\le$ T(n) $\le$ c*f(n)<br>    实际中，将渐近时间复杂度简称为时间复杂度，用以描述算法的时间特性。</p>
<h5 id="2）空间复杂度"><a href="#2）空间复杂度" class="headerlink" title="2）空间复杂度"></a>2）空间复杂度</h5><p>算法的存储空间: 输入数据所占空间, 程序本身所占空间, 辅助变量所占空间<br>空间复杂度<br>      S(n)&#x3D;O(f(n))<br>   表示随着问题规模 n 的增大，算法运行所需存储量的增长率与 f(n) 的增长率相同。<br>存储密度<br>    d&#x3D;数据本身存储量&#x2F;实际所占存储量</p>
<h1 id="Chapter-2-线性表"><a href="#Chapter-2-线性表" class="headerlink" title="Chapter 2 线性表"></a>Chapter 2 线性表</h1><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><h3 id="形式定义"><a href="#形式定义" class="headerlink" title="形式定义"></a>形式定义</h3><p>由n (n $\neq$ 0) 个数据元素组成的有序序列。<br>Linear_list &#x3D; (D, S)<br>     其中：D&#x3D;{ai | ai $\in$D0 , i&#x3D;0,1,$\dots$ , n-1     n $\ge$ 0}<br>         R&#x3D;{N}  N&#x3D;{&lt;ai-1 , ai&gt;| ai-1 , ai $\in$D0 , i&#x3D;1,2,$\dots$ , n-1 }  D0为某个数据对象<br>         或者简记为：(a0, a1, …, ai , …an-1 )  n $\ge$ 0（n为表长。 当n&#x3D;0，称为空表）</p>
<h3 id="线性表的特点"><a href="#线性表的特点" class="headerlink" title="线性表的特点"></a>线性表的特点</h3><pre><code>在数据元素的非空有限集合
</code></pre>
<p>1,数据元素间是线性关系，数据元素在表中的位置只取决于其序号<br>2.存在唯一的一个被称作“第一个”的数据元素和唯一的一个被称作“最后一个”的数据元素<br>3.除第一个外，每个数据元素均只有一个前驱；除最后一个外，每个数据元素均只有一个后继</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct</span><br><span class="line">      &#123;   datatype  data[MAXSIZE];   </span><br><span class="line">           int  last;//最后一个元素在数组中的位置</span><br><span class="line">       &#125; SeqList;    </span><br></pre></td></tr></table></figure></div>
<p>定义一个顺序表的存储变量：<br>       SeqList L;<br>指向SeqList 类型的指针 SeqList *p; p是一个指针变量，通过“p&#x3D;(SeqList )malloc(sizeof(SeqList));”操作来获得顺序表的存储空间，p中存放的是顺序表的地址。</p>
<p>线性表的表长表示为：(*p).last＋1，或者 p-&gt;last+1<br>线性表中数据元素顺序存储的基址为：p-&gt;data<br>线性表中数据元素的存储或表示为：p-&gt;data[0] ～ p-&gt;data[p-&gt;last]</p>
<h4 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h4><pre><code>顺序表的初始化即构造一个空表，对表是一个加工型的运算，因此，将 L设为指针参数，首先动态分配存储空间，然后，将表中 last 指针置为－1，表示表中没有数据元素
</code></pre>
<p>顺序表初始化</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SeqList *init_SeqList( )</span><br><span class="line"> &#123;  </span><br><span class="line">    SeqList *p;</span><br><span class="line">    p= (SeqList *)malloc(sizeof(SeqList)); /*申请顺序表的存储空间*/</span><br><span class="line">     if  (p) </span><br><span class="line">          &#123;  p-&gt;last=-1;</span><br><span class="line">              return p; </span><br><span class="line">          &#125;        /*返回顺序表的存储地址*/       </span><br><span class="line">    else   return –1;         /*申请不成功，返回错误代码-1 */</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p> 设调用函数为主函数，主函数对初始化函数的调用如下：<br> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> main() </span><br><span class="line">&#123; </span><br><span class="line">		SeqList *L;</span><br><span class="line">         L=Init_SeqList();</span><br><span class="line">        …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h4 id="顺序表的插入算法"><a href="#顺序表的插入算法" class="headerlink" title="顺序表的插入算法"></a>顺序表的插入算法</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int Insert_SeqList(SeqList *L,int i,DataType x)</span><br><span class="line"> &#123;  int j;</span><br><span class="line">    if (L-&gt;last==MAXSIZE-1) </span><br><span class="line">      &#123;printf(&quot;表满&quot;); </span><br><span class="line">        return -1;      /*表空间已满，不能插入，返回错误代码-1*/</span><br><span class="line">      &#125; </span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;last+2) /*检查插入位置的正确性*/</span><br><span class="line">       &#123;  printf(&quot;位置错&quot;) ;</span><br><span class="line">           return 0; /*插入位置参数错，返回错误代码0 */</span><br><span class="line">        &#125; 　　</span><br><span class="line">    for (j=L-&gt;last;j&gt;=i-1;j--)</span><br><span class="line">          L-&gt;data[j+1]=L-&gt;data[j]; /*结点移动 */</span><br><span class="line">    L-&gt;data[i-1]=x;　　　　　        /*新元素插入*/</span><br><span class="line">    L-&gt;last++; 　　 /*last指向新的最后元素*/</span><br><span class="line">    return 1;　　　 /*插入成功，返回成功代码1 */</span><br></pre></td></tr></table></figure></div>
<h4 id="顺序表的删除算法"><a href="#顺序表的删除算法" class="headerlink" title="顺序表的删除算法"></a>顺序表的删除算法</h4> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int Delete_SeqList(SeqList *L,int i)</span><br><span class="line">&#123;</span><br><span class="line"> int j;</span><br><span class="line"> if (i&lt;1 || i&gt;L-&gt;last+1)           /*检查空表及删除位置的合法性*/</span><br><span class="line">     &#123;  printf (&quot;不存在第i个元素&quot;);  </span><br><span class="line">        return 0;                  /*不能删除，返回错误代码0*/</span><br><span class="line">     &#125;</span><br><span class="line"> for (j=i;j&lt;=L-&gt;last;j++)</span><br><span class="line">   L-&gt;data[j-1]=L-&gt;data[j];        /*数据元素向前移动*/</span><br><span class="line"> L-&gt;last--;                        /* last指向新的最后元素*/</span><br><span class="line"> return 1;                         /*删除成功，返回成功代码1*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="顺序表的合并"><a href="#顺序表的合并" class="headerlink" title="顺序表的合并"></a>顺序表的合并</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void merge(SeqList *A, SeqList *B, SeqList *C)</span><br><span class="line">  &#123; </span><br><span class="line">    int i,j,k;</span><br><span class="line">    i=0; j=0; k=0;</span><br><span class="line">    while ( i&lt;=A-&gt;last &amp;&amp; j&lt;=B-&gt;last ) </span><br><span class="line">                                            /*将A和B的当前元素较小者复制到表C*/</span><br><span class="line">    if (A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">                C-&gt;data[k++]=A-&gt;data[i++];</span><br><span class="line">        else  C-&gt;data[k++]=B-&gt;data[j++];</span><br><span class="line">  while (i&lt;=A-&gt;last ) 	/*将A中剩余元素复制到表C*/</span><br><span class="line">           C-&gt;data[k++]= A-&gt;data[i++];</span><br><span class="line">  while (j&lt;=B-&gt;last )        /*将B中剩余元素复制到表C */</span><br><span class="line">           C-&gt;data[k++]=B-&gt;data[j++];</span><br><span class="line">   C-&gt;last=k-1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<h4 id="线性表的优缺点"><a href="#线性表的优缺点" class="headerlink" title="线性表的优缺点"></a>线性表的优缺点</h4><p>优点</p>
<ul>
<li>逻辑相邻，物理相邻</li>
<li>可随机存取任一元素</li>
<li>存储空间使用紧凑</li>
</ul>
<p>缺点</p>
<ul>
<li>插入、删除操作需要移动大量的元素</li>
<li>预先分配空间需按最大空间分配，利用不充分</li>
<li>表容量扩充困难</li>
</ul>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>节点</p>
<h1 id="Chapter3-栈与队列"><a href="#Chapter3-栈与队列" class="headerlink" title="Chapter3 栈与队列"></a>Chapter3 栈与队列</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈 是一种特殊的线性表，限定插入和删除操作只能在表尾进行。具有后进先出(LIFO—Last In First Out )的特点。<br>定义在栈结构上的基本运算<br>       (1)  生成空栈操作<br>       (2)  判栈空函数<br>       (3)  数据元素入栈操作<br>       (4)  数据元素出栈函数<br>       (5)  取栈顶元素函数<br>       (6)  置栈空操作<br>       (7)  求当前栈元素个数函数</p>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>栈的顺序存储结构<br>一个栈独占一组地址连续的存储单元<br>类型定义<br>数组(栈空间)+栈顶指示<br>    通常0下标端设为栈底，栈顶指针top值为-1，表示空栈<br>和顺序表相似，顺序栈的类型描述如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define  MAXSIZE  1024   </span><br><span class="line">typedef  struct</span><br><span class="line"> &#123;datatype  data[MAXSIZE];</span><br><span class="line"> int  top;</span><br><span class="line"> &#125;SeqStack；</span><br></pre></td></tr></table></figure></div>
<p>定义一个指向顺序栈的指针：  SeqStack  *s;</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S-&gt;top == 0 (此时出栈下溢)</span><br><span class="line">S-&gt;top==MAXSIZE -1 此时入栈上溢</span><br></pre></td></tr></table></figure></div>
<h3 id="置空栈算法"><a href="#置空栈算法" class="headerlink" title="置空栈算法"></a>置空栈算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SeqStack *Init_SeqStack()</span><br><span class="line"> &#123; SeqStack  *s;</span><br><span class="line">   s=(SeqStack *) malloc(sizeof(SeqStack)); /*申请栈空间*/</span><br><span class="line">   if (!s)</span><br><span class="line">      &#123; printf(”空间不足”\n);</span><br><span class="line">        return NULL;     /*未申请到足够大的存储空间，返回空指针*/</span><br><span class="line">      &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123; s-&gt;top=-1;         /*初始化栈顶指针*/</span><br><span class="line">      return s;             /*申请到栈空间，返回栈空间地址*/</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="判栈空算法"><a href="#判栈空算法" class="headerlink" title="判栈空算法"></a>判栈空算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Empty_SeqStack(SeqStack *s)</span><br><span class="line">&#123;  if (s-&gt;top==-1)</span><br><span class="line">    return 1;    /*空栈返回1*/，</span><br><span class="line">  else</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="入栈算法"><a href="#入栈算法" class="headerlink" title="入栈算法"></a>入栈算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Push_SeqStack(SeqStack *s,datatype  x)</span><br><span class="line">  &#123;  if (s-&gt;top==MAXSIZE-1)</span><br><span class="line">          return 0;         /*栈满不能入栈，返回错误代码0*/</span><br><span class="line">     else</span><br><span class="line">        &#123; s-&gt;top++;       /*栈顶指针向上移动*/</span><br><span class="line">          s-&gt;data[s-&gt;top]=x; /*将x至入新的栈顶*/</span><br><span class="line">          return 1;                 /*入栈成功，返回成功代码1 */</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="出栈算法"><a href="#出栈算法" class="headerlink" title="出栈算法"></a>出栈算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Pop_SeqStack(SeqStack *s,datatype *x)</span><br><span class="line"> &#123;  /*通过*x返回原栈顶元素*/</span><br><span class="line">    if (Empty_SeqStack(s))</span><br><span class="line">     return 0;       /*栈空不能出栈，返回错误代码0*/</span><br><span class="line">    else</span><br><span class="line">         &#123; *x=s-&gt;data[s-&gt;top];   /*保存栈顶元素值*/</span><br><span class="line">             s-&gt;top--;     /*栈顶指针向下移动*/</span><br><span class="line">            return 1;     /*返回成功代码1 */</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>思考：n个元素依次入栈，可得到多少个合法的出栈序列<br>     (2n)!&#x2F;[(n+1)!*n! ]<br>不同的出栈序列实际上对应着不同的入栈出栈操作，以1记为入栈，0为出栈。则问题实际上是求n个1和n个0构成的全排列，其中任意一个位置，它及它此前的数中，1个个数要大于等于0的个数。n个1和n个0构成的全排列数为：(2n)!&#x2F;[n!*n! ]<br>在n个0和n个1构成的2n个数的序列中，假设第一次出现0的个数大于1个个数（即0的个数比1的个数大一）的位置为k，则k为奇数，k之前有相等数目的0和1，各为(k-1)&#x2F;2.  若把这k个数，0换成1，1换成0 ，则原序列唯一对应上一个n＋1个1和n－1个0的序列。反之，任意一个由n＋1个1和n－1个0构成的序列也唯一的对应一个这样不合要求的序列。由于一一对应，故这样不合要求的序列数实际上等于有n＋1个1和n－1个0构成的排列数，即(2n)!&#x2F;(n+1)(n-1)。<br>因此合法的个数为：(2n)!&#x2F;[n!<em>n! ]- (2n)!&#x2F;[(n+1)!</em>(n-1)! ]&#x3D; (2n)!&#x2F;[(n+1)!*n! ] </p>
</blockquote>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>链式栈无栈满问题，空间可扩充</li>
<li>插入与删除仅在栈顶处执行</li>
<li>链式栈的栈顶在链头</li>
<li>适合于多栈操作</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct node</span><br><span class="line">     &#123; datatype data;</span><br><span class="line">       struct node *next;</span><br><span class="line">   &#125;StackNode，* LinkStack;</span><br><span class="line">    定义top为栈顶指针：   LinkStack  top ;</span><br></pre></td></tr></table></figure></div>
<p>栈中的主要运算是在栈顶插入、删除，显然在链表的头部做栈顶是最方便的。<br>链栈基本操作的实现如下：</p>
<p>置空栈<br>    仅是需要将栈顶指针置为空即可。</p>
<h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Empty_LinkStack(LinkStack top)  </span><br><span class="line">&#123; if (top==NULL) return 1;     </span><br><span class="line">     else return 0;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Push_LinkStack(LinkStack top, datatype x)</span><br><span class="line">&#123; StackNode *p;</span><br><span class="line">   p=(StackNode *)malloc(sizeof(StackNode));</span><br><span class="line">   p&gt;data=x; </span><br><span class="line">   p&gt;next=top;</span><br><span class="line">   top=p;</span><br><span class="line">   return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Pop_LinkStack (LinkStack top, datatype *x)</span><br><span class="line">  &#123;  StackNode *p;</span><br><span class="line">     if (top==NULL) return NULL;</span><br><span class="line">     else &#123;*x= top&gt;data;</span><br><span class="line">               p=top;  </span><br><span class="line">               top=top&gt;next;</span><br><span class="line">               free (p);</span><br><span class="line">               return top;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="栈与递归过程"><a href="#栈与递归过程" class="headerlink" title="栈与递归过程"></a>栈与递归过程</h2><p>递归的含义<br>    函数、过程或者数据结构的内部又直接或者间接地由自身定义。</p>
<p>适合于应用递归的场合<br>规模较大的问题可以化解为规模较小的问题，且二者处理(或定义)的方式一致；<br>当问题规模降低到一定程度时是可以直接求解的(终止条件)</p>
<h3 id="Hanoi-tower"><a href="#Hanoi-tower" class="headerlink" title="Hanoi tower"></a>Hanoi tower</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void Hanoi(int n,char a,char b,char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return ;</span><br><span class="line">    Hanoi(n-1,a,c,b);</span><br><span class="line">    printf(&quot;Move disk %d from %c to %c\n&quot;,n,a,c);</span><br><span class="line">    Hanoi(n-1,b,c,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    Hanoi(n,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="递归实现原理"><a href="#递归实现原理" class="headerlink" title="递归实现原理"></a>递归实现原理</h3><p>利用栈，栈中每个元素称为工作记录，分成三个部分：</p>
<ul>
<li>返回地址  实在参数表(变参和值参)   局部变量</li>
<li>发生调用时，保护现场，即当前的工作记录入栈，然后<br> 转入被调用的过程</li>
<li>一个调用结束时，恢复现场，即若栈不空，则退栈，从<br> 退出的返回地址处继续执行下去</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><pre><code>是一种特殊的线性表，限定插入和删除操作分别在表的两端进行。具有先进先出(FIFO—First In First Out)的特点。
</code></pre>
<h3 id="定义在队列结构上的基本运算"><a href="#定义在队列结构上的基本运算" class="headerlink" title="定义在队列结构上的基本运算"></a>定义在队列结构上的基本运算</h3><p>(1)构造空队列操作<br>(2)判队空否函数<br>(3)元素入队操作<br>(4)元素出队函数<br>(5)取队头元素函数<br>(6) 队列置空操作<br>(7)求队中元素个数函数</p>
<blockquote>
<p>进队时队尾指针先进一  rear &#x3D; rear + 1，再将新元素按 rear 指示位置加入。<br>出队时队头指针先进一 front &#x3D; front + 1，再将front指示 的元素取出。<br>队满时再进队将溢出出错；队空时再出队将队空处理。</p>
</blockquote>
<h3 id="用单链表表示的队列"><a href="#用单链表表示的队列" class="headerlink" title="用单链表表示的队列"></a>用单链表表示的队列</h3><pre><code>队头指针 + 队尾指针
</code></pre>
<ul>
<li>队头在链头，队尾在链尾。</li>
<li>链式队列在进队时无队满问题，但有队空问题。</li>
<li>队空条件为 front -&gt;next&#x3D;&#x3D; NULL</li>
</ul>
<h3 id="用单循环链表定义的队列"><a href="#用单循环链表定义的队列" class="headerlink" title="用单循环链表定义的队列"></a>用单循环链表定义的队列</h3><pre><code>队尾指针
</code></pre>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><pre><code> 将顺序队列的存储区假想为一个环状空间
</code></pre>
<p> 类型定义:一维数组(队列空间) + 头指针 + 尾指针<br>队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素.<br>优点：不需要移动元素，操作效率高，空间的利用率也很高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct     &#123; </span><br><span class="line">      datatype data[MAXSIZE];      /*数据的存储区*/</span><br><span class="line">      int front,rear;         /*队头队尾指针*/</span><br><span class="line">      int num;                /*队中元素的个数*/</span><br><span class="line">    &#125;c_SeQueue;          /*循环队*/</span><br><span class="line"></span><br><span class="line">c_SeQueue *q;</span><br></pre></td></tr></table></figure></div>
<p>存储队列的数组被当作首尾相接的表处理。<br>为解决如何判断队列的满与空问题：牺牲一个存储单元 。<br>队头、队尾指针加1时从maxSize -1直接进到0，可用语言的取模(余数)运算实现。<br>出队: q -&gt;front &#x3D; (q -&gt; front + 1) % maxSize;<br>入队:  q-&gt;rear &#x3D; (q-&gt; rear + 1) % maxSize;<br>队列初始化： q-&gt; front &#x3D; q-&gt; rear &#x3D; 0;<br>队空条件： q-&gt; front &#x3D;&#x3D; q-&gt; rear;<br>队满条件：(q-&gt; rear + 1) % maxSize &#x3D;&#x3D; q-&gt; front</p>
<blockquote>
<p>思考：循环队列中当前元素的个数为多少？<br>当前元素个数(q-&gt;rear- q-&gt; front+maxsize)%maxsize</p>
</blockquote>
<h3 id="循环队入队算法"><a href="#循环队入队算法" class="headerlink" title="循环队入队算法"></a>循环队入队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int In_SeQueue ( CSeQueue *q , datatype  x)</span><br><span class="line">&#123;  if(q-&gt;num==MAXSIZE)</span><br><span class="line">    &#123; printf(&quot;队满&quot;);</span><br><span class="line">      return -1;        /*队满不能入队*/</span><br><span class="line">     &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123; q&gt;rear=(q-&gt;rear+1) % MAXSIZE;</span><br><span class="line">      q-&gt;data[q-&gt;rear]=x;</span><br><span class="line">      q-&gt;num++;</span><br><span class="line">      return 1;    	/*入队完成*/</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环队出队算法"><a href="#循环队出队算法" class="headerlink" title="循环队出队算法"></a>循环队出队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Out_SeQueue (CSeQueue *q, datatype *x)</span><br><span class="line">  &#123;if (q-&gt;num==0)</span><br><span class="line">        &#123; printf(&quot;队空&quot;)；</span><br><span class="line">          return -1;   	             /*队空不能出队*/</span><br><span class="line">        &#125;</span><br><span class="line"> else &#123;q-&gt;front=(q-&gt;front+1) % MAXSIZE;</span><br><span class="line">          *x=q-&gt;data[q-&gt;front]; 	/*读出队头元素*/</span><br><span class="line">           q-&gt;num--; </span><br><span class="line">          return 1;                           /*出队完成*/</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="构建一个空的循环队算法"><a href="#构建一个空的循环队算法" class="headerlink" title="构建一个空的循环队算法"></a>构建一个空的循环队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSeQueue* Init_SeQueue()</span><br><span class="line"> &#123; CSeQueue *q;</span><br><span class="line">    q=(CSeQueue *)malloc(sizeof(CSeQueue));</span><br><span class="line">    q-&gt;front=q-&gt;rear=MAXSIZE-1;</span><br><span class="line">    q-&gt;num=0;</span><br><span class="line">    return q;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环队入队算法-1"><a href="#循环队入队算法-1" class="headerlink" title="循环队入队算法"></a>循环队入队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int In_SeQueue ( CSeQueue *q , datatype  x)</span><br><span class="line">&#123;  if(q-&gt;num==MAXSIZE)</span><br><span class="line">    &#123; printf(&quot;队满&quot;);</span><br><span class="line">      return -1;        /*队满不能入队*/</span><br><span class="line">     &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123; q&gt;rear=(q-&gt;rear+1) % MAXSIZE;</span><br><span class="line">      q-&gt;data[q-&gt;rear]=x;</span><br><span class="line">      q-&gt;num++;</span><br><span class="line">      return 1;    	/*入队完成*/</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环队出队算法-1"><a href="#循环队出队算法-1" class="headerlink" title="循环队出队算法"></a>循环队出队算法</h3>  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Out_SeQueue (CSeQueue *q, datatype *x)</span><br><span class="line">    &#123;if (q-&gt;num==0)</span><br><span class="line">          &#123; printf(&quot;队空&quot;)；</span><br><span class="line">            return -1;   	             /*队空不能出队*/</span><br><span class="line">          &#125;</span><br><span class="line">   else &#123;q-&gt;front=(q-&gt;front+1) % MAXSIZE;</span><br><span class="line">            *x=q-&gt;data[q-&gt;front]; 	/*读出队头元素*/</span><br><span class="line">             q-&gt;num--; </span><br><span class="line">            return 1;                           /*出队完成*/</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="判循环队空队算法"><a href="#判循环队空队算法" class="headerlink" title="判循环队空队算法"></a>判循环队空队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Empty_SeQueue(CSeQueue *q)</span><br><span class="line">  &#123;  if (q&gt;num==0)  return 1;</span><br><span class="line">     else  return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="实验作业"><a href="#实验作业" class="headerlink" title="实验作业"></a>实验作业</h2><p>利用栈实现如下两种类型的进制转换：<br>（1）十进制转换为二进制；<br>（2）二进制转换为十进制。<br>要求：从键盘输入要转换的十进制数或二进制数，如输入的为十进制数则以‘$’结束，如输入的为二进制数则以‘#’结束。利用结束符‘$’‘#’自动识别要做的转换类型，并将对应的转换结果输出。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> @author 李昕烨 2022213259</span><br><span class="line"> 2023/11/12*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">struct Stack</span><br><span class="line">&#123;</span><br><span class="line">    int top;</span><br><span class="line">    int cap;</span><br><span class="line">    int* array;</span><br><span class="line">&#125;;</span><br><span class="line">struct Stack* init(int cap)</span><br><span class="line">&#123;</span><br><span class="line">    struct Stack* stack=(struct Stack*)malloc(sizeof(struct Stack));</span><br><span class="line">    stack-&gt;cap=cap;</span><br><span class="line">    stack-&gt;top=-1;</span><br><span class="line">    stack-&gt;array=(int*)malloc(stack-&gt;cap*sizeof(int));</span><br><span class="line">&#125;</span><br><span class="line">int full(struct Stack* stack)</span><br><span class="line">&#123;</span><br><span class="line">    return stack-&gt;top==stack-&gt;cap-1;</span><br><span class="line">&#125;</span><br><span class="line">int empty(struct Stack* stack)</span><br><span class="line">&#123;</span><br><span class="line">    return stack-&gt;top==-1;</span><br><span class="line">&#125;</span><br><span class="line">void push(struct Stack* stack, int num) &#123;</span><br><span class="line">    if (!full(stack))</span><br><span class="line">        stack-&gt;array[++stack-&gt;top] = num;</span><br><span class="line">&#125;</span><br><span class="line">int pop(struct Stack* stack) &#123;</span><br><span class="line">    if (!empty(stack))</span><br><span class="line">        return stack-&gt;array[stack-&gt;top--];</span><br><span class="line">    return -1; // 栈为空，返回错误值</span><br><span class="line">&#125;</span><br><span class="line">//二进制转10进制</span><br><span class="line">int todemical(char *num)</span><br><span class="line">&#123;</span><br><span class="line">    /*int temp=0;</span><br><span class="line">    int k=1;</span><br><span class="line">    int p=2;</span><br><span class="line">    while(num!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=temp+(num%10)*2*k;</span><br><span class="line">        num=num/10;</span><br><span class="line">        k=p;</span><br><span class="line">        printf(&quot;%d&quot;, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;*/</span><br><span class="line">     int decimalNum = 0;</span><br><span class="line">    int len = strlen(num);</span><br><span class="line">    int base = 1;</span><br><span class="line">    for (int i = len - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (num[i] == &#x27;1&#x27;)</span><br><span class="line">            decimalNum += base;</span><br><span class="line">        base *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return decimalNum;</span><br><span class="line">&#125;</span><br><span class="line">void tobinary(int num)</span><br><span class="line">&#123;</span><br><span class="line">     struct Stack* stack = init(32); // 假定最多32位二进制数</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        push(stack, num % 2);</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Binary Result: &quot;);</span><br><span class="line">    while (!empty(stack))</span><br><span class="line">        printf(&quot;%d&quot;, pop(stack));</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    free(stack-&gt;array);</span><br><span class="line">    free(stack);</span><br><span class="line">&#125;</span><br><span class="line">bool test(int result)</span><br><span class="line">&#123;</span><br><span class="line">    while(result&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(result%10&gt;2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        result=result/10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input[100];</span><br><span class="line">    int result;</span><br><span class="line">    printf(&quot;Enter a number (use &#x27;$&#x27; for decimal and &#x27;#&#x27; for binary): &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, input);</span><br><span class="line">     if (input[strlen(input) - 1] == &#x27;$&#x27;) &#123;</span><br><span class="line">        input[strlen(input) - 1] = &#x27;\0&#x27;; // 移除 &#x27;$&#x27; 结束符</span><br><span class="line">        result = atoi(input); // 将字符串转换为整数</span><br><span class="line">        tobinary(result);// 十进制转二进制</span><br><span class="line">    &#125; else if (input[strlen(input) - 1] == &#x27;#&#x27;) &#123;</span><br><span class="line">        input[strlen(input) - 1] = &#x27;\0&#x27;; // 移除 &#x27;#&#x27; 结束符</span><br><span class="line">        result = atoi(input);</span><br><span class="line">        int t=result;</span><br><span class="line">        if(!test(result))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Invalid input format.\n&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        result=todemical(input); // 二进制转十进制</span><br><span class="line">        printf(&quot;Demical result: %d&quot;, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Invalid input format.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Chapter-5-树与二叉树"><a href="#Chapter-5-树与二叉树" class="headerlink" title="Chapter 5 树与二叉树"></a>Chapter 5 树与二叉树</h1><h2 id="树的结构和基本操作"><a href="#树的结构和基本操作" class="headerlink" title="树的结构和基本操作"></a>树的结构和基本操作</h2><pre><code> 树是一类重要的非线性数据结构，是以分支关系定义的层次结构。
</code></pre>
<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树是由n(n $\ge$ 0)个结点组成的有限集合T，非空树满足：<br>    1)有一个称之为根(root)的结点。<br>    2)除根以外的其余结点被分成m(0 $\le$ m&lt;n)个互不相交的集合T1,T2 ,$\cdots$,Tm,其中每一个集合本身又是一棵树，且称为根的子树。</p>
<h3 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h3><pre><code>  除根结点外，每个结点都仅有一个前趋(父)结点
</code></pre>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>结点的度    结点拥有的子树数目。</li>
<li>叶子(终端)结点    度为0的结点。</li>
<li>分支(非终端)结点    度不为0的结点。</li>
<li>树的度    树的各结点度的最大值。</li>
<li>内部结点    除根结点之外的分支结点。</li>
<li>双亲与孩子(父与子)结点    结点的子树的根称为该结点的孩子；该结点称为孩子的双亲。</li>
<li>兄弟    属于同一双亲的孩子。</li>
<li>结点的祖先    从根到该结点所经分支上的所有结点。</li>
<li>结点的子孙    该结点为根的子树中的任一结点。</li>
<li>结点的层次   表示该结点在树中的相对位置。根为第一层，其它的结点依次下推；若某结点在第L层上，则其孩子在第L+1层上。</li>
<li>堂兄弟   双亲在同一层的结点互为堂兄弟。</li>
<li>树的深(高)度   树中结点的最大层次。</li>
<li>有序树   树中各结点的子树从左至右是有次序的，不能互换。否则，称为无序树。</li>
<li>路径长度   从树中某结点Ni出发，能够“自上而下地”通过树中结点到达结点Nj，则称Ni到Nj存在一条路径，路径长度等于这两个结点之间的分支数。</li>
<li>树的路径长度   从根到每个结点的路径长度之和。</li>
<li>森林   是m(m $\ge$ 0)棵互不相交的树的集合。</li>
</ol>
<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p>1)初始化操作                  initiate(T)<br>2)求根函数                      root(T) &#x2F; root(x)<br>3)求双亲函数                  parent(T,x)<br>4)求孩子结点函数          child(T,x,i)<br>5)求右兄弟函数              right_sibling(T,x)<br>6)建树函数                      crt_tree(x,F)<br>7)插入子树操作              ins_child(y,i,x)<br>8)删除子树操作              del_child(x,i)<br>9)遍历操作                      traverse(T)<br>10)清除结构操作            clear(T)</p>
<h2 id="二叉树的定义与性质"><a href="#二叉树的定义与性质" class="headerlink" title="二叉树的定义与性质"></a>二叉树的定义与性质</h2><h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>二叉树是n(n $\ge$ 0)个结点的有限集合，它或为空树(n&#x3D;0)，或由一个根结点和两棵互不相交的左子树和右子树的二叉树组成。</p>
<h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><ul>
<li>定义是递归</li>
<li>的0$\le$结点的度$\le$ 2</li>
<li>是有序树</li>
</ul>
<h4 id="两种特殊的二叉树"><a href="#两种特殊的二叉树" class="headerlink" title="两种特殊的二叉树"></a>两种特殊的二叉树</h4><p>   - 满二叉树   每一层上的结点数都是最大结点数。<br>   - 完全二叉树   只有最下面两层结点的度可小于2，而最下一层的叶结点集中在左边若干位置上。</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>性质1   二叉树的第i层上至多有2i-1(i $\ge$ 1)个结点。<br>性质2   深度为k的二叉树至多有2k-1个结点(k $\ge$ 1)。<br>性质3   对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2 ，则n0 &#x3D; n2 + 1。<br>性质4   具有n个结点的完全二叉树的深度为$\lfloor \log_{2}{n} \rfloor$+1。<br>性质5   一棵具有n个结点的完全二叉树(又称顺序二叉树)，对其结点按层从上至下(每层从左至右)进行1至n的编号，则对任一结点i(1in)有：<br>    (1)若i&gt;1，则i的双亲是$\lfloor i&#x2F;2 \rfloor$；若i&#x3D;1，则i是根，无双亲。<br>    (2)若2$\le$i$\le$n，则i的左孩子是2i；否则， i无左孩子。<br>    (3)若2i+1$\le$n，则i的右孩子是2i+1；否则， i无右孩子。</p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>完全二叉树：按完全二叉树编号存放<br>三元组：存储结点数据和左、右孩子在向量中的序号<br>双亲：存储结点数据和其父结点的序号<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453.png"
                     
                ></p>
<h4 id="二叉链表的类型定义"><a href="#二叉链表的类型定义" class="headerlink" title="二叉链表的类型定义"></a>二叉链表的类型定义</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef </span><br><span class="line">struct btnode&#123;</span><br><span class="line">  btnode *lchild,rchild;</span><br><span class="line">  elemtp  data;</span><br><span class="line">&#125; BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></div>
<p>定义指针变量，用来存放根结点地址，通常用该指针标识一个二叉树<br>BiTree root;</p>
<h4 id="三叉链表的类型定义"><a href="#三叉链表的类型定义" class="headerlink" title="三叉链表的类型定义"></a>三叉链表的类型定义</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">struct btnode&#123;</span><br><span class="line"> btnode *lchild,rchild;</span><br><span class="line"> btnode *parent;</span><br><span class="line"> elemtp  data;</span><br><span class="line">&#125; *BiTree;</span><br></pre></td></tr></table></figure></div>

<p>若要建立不带头结点的二叉树，可描述如下：<br>建立一棵空的不带头结点的二叉树</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BiTree Initiate ()     /*初始建立一棵空的不带头结点的二叉树*/</span><br><span class="line">     &#123;  BiTNode  *bt;</span><br><span class="line">        bt=NULL;</span><br><span class="line">        return bt;</span><br><span class="line">     &#125;</span><br><span class="line">在主函数中，可以通过如下方式调用Initiate函数：</span><br><span class="line">main ( )</span><br><span class="line">  &#123;BiTree t ;        /*定义根结点指针变量*/</span><br><span class="line">    t =Initiate ();</span><br><span class="line">     ……</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Create-x，lbt，rbt"><a href="#Create-x，lbt，rbt" class="headerlink" title="Create(x，lbt，rbt)"></a>Create(x，lbt，rbt)</h4><p>生成一棵以x为根结点的数据域值以lbt和rbt为左右子树的二叉树。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BiTree Create(elemtype x, BiTree lbt, BiTree rbt) </span><br><span class="line">  &#123;BiTree  p;</span><br><span class="line">   if((p=(BiTNode*)malloc(sizeof(BiTNode)))==NULL) </span><br><span class="line">       return NULL;</span><br><span class="line">    p&gt;data=x;</span><br><span class="line">    p&gt;lchild=lbt;</span><br><span class="line">    p&gt;rchild=rbt; </span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="InsertL-bt-x-parent"><a href="#InsertL-bt-x-parent" class="headerlink" title="InsertL(bt, x, parent)"></a>InsertL(bt, x, parent)</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453%201.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    BiTree InsertL(BiTree bt，elemtype x，BiTree parent)</span><br><span class="line">      &#123;BiTree  p;</span><br><span class="line">       if (parent==NULL)</span><br><span class="line">        &#123;printf(&quot;\n插入出错&quot;)；</span><br><span class="line">         return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">      if ((p=(BiTNode *)malloc(sizeof(BiTNode)))==NULL) return NULL;</span><br><span class="line">      p-&gt;data=x;</span><br><span class="line">      p-&gt;lchild=NULL;</span><br><span class="line">      p-&gt;rchild=NULL;</span><br><span class="line">      if (parent-&gt;lchild==NULL) parent-&gt;lchild=p;</span><br><span class="line">      else &#123;p-&gt;lchild=parent-&gt;lchild;</span><br><span class="line">               parent-&gt;lchild=p;</span><br><span class="line">              &#125;</span><br><span class="line">      return bt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>InsertR(bt，x，parent)：功能类同于 InsertL(bt, x, parent) ，算法略。</p>
<h4 id="DeleteL-bt，parent"><a href="#DeleteL-bt，parent" class="headerlink" title="DeleteL(bt，parent)"></a>DeleteL(bt，parent)</h4><pre><code>在二叉树bt中删除parent的左子树
</code></pre>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> BiTree  DeleteL(BiTree bt，BiTree parent) </span><br><span class="line">     &#123; BiTree  p;</span><br><span class="line">        if (parent==NULL||parent-&gt;lchild==NULL)</span><br><span class="line">          &#123; printf(&quot;\n删除出错&quot;)；</span><br><span class="line">            return NULL;</span><br><span class="line">          &#125;</span><br><span class="line">        p=parent-&gt;lchild;</span><br><span class="line">        parent-&gt;lchild=NULL;</span><br><span class="line">        free(p);  </span><br><span class="line"> /*当*p为非叶子结点时，这样删除仅释放了所删子树根结点的空间，*/</span><br><span class="line">/*若要删除子树分支中的结点，需用后面介绍的遍历操作来实现。*/</span><br><span class="line">        return bt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p> DeleteR(bt，parent)：算法略。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ol>
<li>遍历的目的 非线性结构Þ线性结构</li>
<li>遍历的概念  指按某条搜索路线走遍二叉树的每个结点，使得树中每个结点都被访问一次，且仅被访问一次。</li>
<li>典型的遍历方法</li>
</ol>
<ul>
<li>先(根)序遍历  DLR</li>
<li>中(根)序遍历  LDR</li>
<li>后(根)序遍历  LRD</li>
<li>层序遍历</li>
</ul>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185653.png"
                     
                ></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185759%201.png"
                     
                ></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185809.png"
                     
                ></p>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><blockquote>
<p>队列实现:遍历从根结点开始，首先将根结点入队，然后开始执行循环:结点出队、访问该结点、其左右儿子入队<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%9B%BE%E7%89%872.png"
                     
                ></p>
</blockquote>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204806.png"
                     
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204827.png"
                     
                ></p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="构建二叉树的二叉链表"><a href="#构建二叉树的二叉链表" class="headerlink" title="构建二叉树的二叉链表"></a>构建二叉树的二叉链表</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%9B%BE%E7%89%871%201.png"
                     
                ></p>
<h4 id="在二叉树中查找结点值为x的结点"><a href="#在二叉树中查找结点值为x的结点" class="headerlink" title="在二叉树中查找结点值为x的结点"></a>在二叉树中查找结点值为x的结点</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void  pre_find(BiTree bt, ElemType x, BiTree &amp;q)//用q返回</span><br><span class="line">&#123; //F是全局bool型变量，初值为FALSE</span><br><span class="line">    if (bt &amp;&amp; F==FALSE)</span><br><span class="line">     &#123;</span><br><span class="line">          if (bt-&gt;data==x)</span><br><span class="line">          &#123;   q=bt; F=TRUE;&#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;  pre_find(bt-&gt;lchild, x, q);</span><br><span class="line">               pre_find(bt-&gt;rchild, x, q)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="求二叉树中每个结点所处的层次"><a href="#求二叉树中每个结点所处的层次" class="headerlink" title="求二叉树中每个结点所处的层次"></a>求二叉树中每个结点所处的层次</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void  pre_level(BiTree p, int level)</span><br><span class="line">&#123;    </span><br><span class="line">       if (p)</span><br><span class="line">       &#123; </span><br><span class="line">            write(p-&gt;data, level);//实现时可用printf代替</span><br><span class="line">            pre_level(p-&gt;lchild; level+1);</span><br><span class="line">            pre_level(p-&gt;rchild; level+1);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void  pre_height(BiTree p, int level)</span><br><span class="line">&#123;     if (p)</span><br><span class="line">       &#123;  if (h&lt;level)   h=level;</span><br><span class="line">           pre_height(p-&gt;lchild, level+1);</span><br><span class="line">           pre_height(p-&gt;rchild,level+1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void  post_height(BiTree bt,int &amp;h)</span><br><span class="line">&#123;     if (bt==NULL) h=0</span><br><span class="line">       else</span><br><span class="line">       &#123; post_height(bt-&gt;lchild, h1);</span><br><span class="line">          post_height(bt-&gt;rchild,h2);</span><br><span class="line">          h:=1+max(h1,h2);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="复制一颗二叉树"><a href="#复制一颗二叉树" class="headerlink" title="复制一颗二叉树"></a>复制一颗二叉树</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void  pre_copy(BiTree bt; BiTree &amp;q)</span><br><span class="line">&#123;   </span><br><span class="line">    if (bt) </span><br><span class="line">     &#123;      new(q); </span><br><span class="line">            q-&gt;data= bt-&gt;data;</span><br><span class="line">             pre_copy(bt-&gt;lchild, q-&gt;lchild);</span><br><span class="line">             pre_copy(bt-&gt;rchild, q-&gt;rchild);</span><br><span class="line">      &#125;</span><br><span class="line">     else  </span><br><span class="line">           q=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h3><ul>
<li>树的路径长度   从树根到每一个结点的路径上的分支数。</li>
<li>带权路径长度   结点的路径长度与该结点的权之积。</li>
<li>树的带权路径长度   树中所有叶子结点的带权路径长度之和。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%9B%BE%E7%89%872%201.png"
                     
                ></li>
<li>最优二叉树(哈夫曼树)   带权路径长度WPL最小的二叉树。</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20211057.png"
                     
                ></li>
</ul>
<h4 id="哈夫曼树的应用"><a href="#哈夫曼树的应用" class="headerlink" title="哈夫曼树的应用"></a>哈夫曼树的应用</h4><h5 id="最佳判定树"><a href="#最佳判定树" class="headerlink" title="最佳判定树"></a>最佳判定树</h5><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><blockquote>
<p>用于通信和数据传送中字符的二进制编码，可以使电文编码总长度最短<br>   左右分支分别为0,1<br>   字符在叶节点上</p>
</blockquote>
<ul>
<li>哈夫曼编码是不等长编码</li>
<li>哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀</li>
<li>哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1</li>
<li>发送过程：根据由哈夫曼树得到的编码表送出字符数据</li>
<li>接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束</li>
</ul>
<h5 id="哈夫曼编码系统"><a href="#哈夫曼编码系统" class="headerlink" title="哈夫曼编码系统"></a>哈夫曼编码系统</h5><p>[问题描述]<br>设计一个利用哈夫曼算法的编码系统，能完成以下基本要求。<br>[基本要求]<br>（1）键盘输入长为n的字符串， 统计其中每个字符的权值（出现频次），建立哈夫曼树；<br>（2）编码：利用建好的哈夫曼树生成哈夫曼编码；<br>（3）输出编码（在屏幕上显示）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span><stdio.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct node *parent,*left,*right;</span><br><span class="line">	int frequency;</span><br><span class="line">&#125; Node,*huffman;</span><br><span class="line"></span><br><span class="line">//初始化树</span><br><span class="line">Node *create(char data, int frequency)</span><br><span class="line">&#123;</span><br><span class="line">	Node *new=(Node *)malloc(sizeof(Node));</span><br><span class="line">	new-&gt;data=data;</span><br><span class="line">	new-&gt;frequency=frequency;</span><br><span class="line">	new-&gt;left=NULL;</span><br><span class="line">	new-&gt;right=NULL;</span><br><span class="line">	new-&gt;parent=NULL;</span><br><span class="line">	return new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构建Huffman树</span><br><span class="line">huffman build(char data[],int freq[],int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	Node *nodes=(Node *)malloc(sizeof(Node)*(size)*2);</span><br><span class="line">	int index[50];//使用索引数组进行排序</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; 2 * size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		nodes[i] = *create(data[i], freq[i]);</span><br><span class="line">		index[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int k = 0; k &lt; size - 1; k++)//选择排序,按照频率大小排序</span><br><span class="line">	&#123;</span><br><span class="line">		int min, temp;</span><br><span class="line">		for (int i = 2 * k; i &lt; size + k - 1; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			min = i;</span><br><span class="line">			for (int j = i + 1; j &lt; size + k; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (nodes[index[j]].frequency &lt; nodes[index[min]].frequency)</span><br><span class="line">				&#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = index[min];</span><br><span class="line">			index[min] = index[i];</span><br><span class="line">			index[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		Node *n_parent = (Node *) malloc(sizeof(Node));  //创建父节点</span><br><span class="line">        n_parent-&gt;frequency = nodes[index[2 * k]].frequency + nodes[index[2 * k + 1]].frequency;  </span><br><span class="line">        n_parent-&gt;left = &amp;nodes[index[2 * k]];</span><br><span class="line">        n_parent-&gt;right = &amp;nodes[index[2 * k + 1]];</span><br><span class="line">        nodes[index[2 * k]].parent = n_parent;</span><br><span class="line">        nodes[index[2 * k + 1]].parent = n_parent;</span><br><span class="line">        n_parent-&gt;data = &#x27;$&#x27;;  // 父节点数据随意设置，这里使用&#x27;$&#x27;表示 </span><br><span class="line">		nodes[index[size + k]] = *n_parent;</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;nodes[index[2 * size - 2]];</span><br><span class="line">&#125;</span><br><span class="line">void find(huffman root, char code[], int top, char chara)</span><br><span class="line">&#123;</span><br><span class="line">	if (root-&gt;left != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		code[top] = &#x27;0&#x27;;</span><br><span class="line">		find(root-&gt;left, code, top + 1, chara);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		code[top] = &#x27;1&#x27;;</span><br><span class="line">		find(root-&gt;right, code, top + 1, chara);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; root-&gt;data == chara)</span><br><span class="line">	&#123;//打印字符和对应Huffman编码</span><br><span class="line">		printf(&quot;%c: &quot;, root-&gt;data);</span><br><span class="line">		for (int i = 0; i &lt; top; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%c&quot;, code[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char str[1005];</span><br><span class="line">	int freque[128]= &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	memset(str, &#x27;\0&#x27;, sizeof(str));</span><br><span class="line">	memset(freque, 0, sizeof(freque));</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%s&quot;, str);//输入字符串</span><br><span class="line"></span><br><span class="line">	int len = strlen(str);//计算字符频率</span><br><span class="line">	for(int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		freque[(int)str[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	char data[200];</span><br><span class="line">	int freq[200], flag[200], size = 0;</span><br><span class="line">	memset(flag, 0, sizeof(flag));</span><br><span class="line">	//记录字符和对应频率</span><br><span class="line">	for(int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(flag[(int)str[i]] == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[(int)str[i]] = 1;</span><br><span class="line">			freq[size] = freque[(int)str[i]];</span><br><span class="line">			data[size] = str[i];</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	huffman root = build(data, freq, size);</span><br><span class="line">	char code[100];  // 适当设置编码的最大长度</span><br><span class="line">	memset(code, &#x27;\0&#x27;, sizeof(code));</span><br><span class="line">	//输出每个字符Huffman编码</span><br><span class="line">	for(int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		find(root, code, 0, data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h4><pre><code> 树转换为二叉树的规则:每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。
</code></pre>
<ol>
<li>在兄弟结点之间加一连线;</li>
<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉;</li>
<li>以树根为轴心，顺时针旋转45°。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210226145948307.png"
                     
                ></li>
</ol>
<h4 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h4><p>森林是由若干棵树组成的，所以完全可以理解为,森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。<br>森林转换成二叉树的画法:</p>
<ol>
<li>将森林中的每棵树转换成相应的二叉树;</li>
<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线;</li>
<li>以第一棵树的根为轴心顺时针旋转45°。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210226150421261.png"
                     
                ></li>
</ol>
<h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><ul>
<li>先序遍历   先访问树的根结点，然后依次先根遍历根的每棵子树       ABEFCDG(二叉树先序)</li>
<li>后序遍历   先依次后根遍历根的每棵子树，然后访问树的根结点       EFBCGDA(二叉树中序)</li>
</ul>
<h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><h5 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h5><blockquote>
<p>访问第一棵树的根结点；先序遍历第一棵树的根的子树森林； 先序遍历除第一棵树外; 剩余的树构成的森林（逐棵先序遍历每棵子树&#x2F;  对应二叉树的先序遍历)<br> <br> ##### 中序遍历<br>中序遍历第一棵树的根的子树森林;访问第一棵树的根结点;中序遍历第一棵树外剩余的树构成的森林(逐棵后序遍历每棵子树&#x2F;对应二叉树的中序遍历)</p>
</blockquote>
<h1 id="Chapter6-图"><a href="#Chapter6-图" class="headerlink" title="Chapter6 图"></a>Chapter6 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><pre><code>  非线性结构，数据元素之间呈多对多的关系。
</code></pre>
<p>图的定义<br>Graph&#x3D;(V,E)<br>    V：顶点(数据元素)的有穷非空集合。<br>    E：边的有穷集合。<br>图的相关术语<br>顶点   数据元素所构成的结点。<br>无向图   边的顶点偶对是无序的。<br>                (vi, vj)和(vj, vi)代表同一条边(i $\ge$ j)。<br>有向图   边的顶点偶对是有序的。<br>                有向边&lt; vi, vj &gt;也称为弧。<br>                 vi是弧尾&#x2F;初始点； vj是弧头&#x2F;终端点。<br>(无向)完全图   每个顶点与其余顶点都有边的无向图。<br>                 顶点数为n时，边数e&#x3D;n(n-1)&#x2F;2<br>有向完全图   每个顶点与其余顶点都有弧的有向图。<br>                 顶点数为n时，弧数e&#x3D;n(n-1)<br>思考：一无向图的顶点个数为n，则该图最多有（  n(n-1)&#x2F;2  ）条边。<br>稀疏图   有很少边或弧的图。<br>稠密图   有较多边或弧的图。<br>权   图中的边或弧具有一定的大小的概念。<br>网   边&#x2F;弧带权的图。<br>邻接   有边&#x2F;弧相连的两个顶点之间的关系。<br>            存在(vi, vj)，则称vi和vj互为邻接点；<br>              存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi<br>关联(依附)   边&#x2F;弧与顶点之间的关系。<br>            存在(vi, vj)&#x2F; &lt;vi, vj&gt;， 则称该边&#x2F;弧关联于vi和vj<br>子图   对于图G&#x3D;(V,E)和G’&#x3D;(V’,E’)，如果V’V，E’ E，且E’关联的顶点都在V’中，则称G’是G的子图。<br>生成子图   由图的全部顶点和部分边组成的子图称为原图的生成子图。<br>顶点的度   与该顶点相关联的边的数目，记为D(v)。<br>入度ID(v)：有向图中，以该顶点为弧头的弧数目。<br>出度OD(v)：有向图中，以该顶点为弧尾的弧数目。<br>顶点数n、边数e和度数之间的关系:<br>$e&#x3D;\frac{1}{2} \sum_{i&#x3D;1}^{n} D\left ( vi \right )$<br>思考：<br>在一个无向图中，所有顶点的度数之和等于所有边数2倍，<br>在一个有向图中，所有顶点的入度之和等于所有顶点出度之和的1倍。<br>在有n个顶点的有向图中，每个顶点的度最大可达2(n-1)。<br>路径   接续的边构成的顶点序列。<br>路径长度   路径上边或弧的数目&#x2F;权值之和。<br>回路(环)   第一个顶点和最后一个顶点相同的路径。<br>简单路径   除路径起点和终点可以相同外，其余顶点均不相同的路径。<br>简单回路(简单环)   除路径起点和终点相同外，其余项点均不相同的路径。<br>n个顶点的无向完全图中,两个顶点之间简单路径数目为多少？<br>1 + A(n-2,1) + A(n-2,2) + … + A(n-2,n-2)其中A(m,n)是m取n的排列数。<br>连通图   无向图中，任何一对顶点间都存在路径。<br>连通分量   无向图中的极大连通子图。<br>思考：n个顶点组成的连通无向图，其边的个数至少为n-1。<br>思考：一个有n个结点的无向图，最少有（ 1 ）个连通分量，<br>最多有（n）个连通分量。<br>若G是一个非连通无向图，共有28条边，则该图至少有_9_个顶点。<br>生成树   包含图中全部顶点的极小连通子图<br>有向树   图中恰有一个顶点入度为0，其余顶点入度均为1。<br>生成森林   有向图中，包含所有顶点的若干棵有向树构成的子图。</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="数组-邻接矩阵-加权邻接矩阵-顺序存储方式"><a href="#数组-邻接矩阵-加权邻接矩阵-顺序存储方式" class="headerlink" title="数组+邻接矩阵&#x2F;加权邻接矩阵(顺序存储方式)"></a>数组+邻接矩阵&#x2F;加权邻接矩阵(顺序存储方式)</h3><h4 id="无权值的有向图的邻接矩阵"><a href="#无权值的有向图的邻接矩阵" class="headerlink" title="无权值的有向图的邻接矩阵"></a>无权值的有向图的邻接矩阵</h4><p> 设有向图具有 n 个顶点，则用 n 行 n 列的布尔矩阵 A 表示该有向图;并且 A[i,j]  &#x3D;  1 , 如果i 至 j 有一条有向边；A[i,j] &#x3D; 0如果 i 至 j 没有一条有向边。<br> 注意： 顶点i出度: i行之和。顶点i入度: i列之和。</p>
<h4 id="无权值的无向图的邻接矩阵"><a href="#无权值的无向图的邻接矩阵" class="headerlink" title="无权值的无向图的邻接矩阵"></a>无权值的无向图的邻接矩阵</h4><p>设无向图具有 n 个顶点，则用 n 行 n 列的布尔矩阵 A 表示该无向图；并且 A[i,j]  &#x3D;  1 , 如果i 至 j 有一条无向边；A[I,j] &#x3D; 0如果 i 至 j 没有一条无向边。<br>i结点的度: i行或i列之和。<br>必然为对称矩阵，可压缩为上三角矩阵或下三角矩阵。<br>思考：n个顶点的连通图用邻接矩阵表示时,该矩阵至少有2(n-1)个非零元素。<br>n个顶点的强连通图用邻接矩阵表示时,该矩阵至少有n个非零元素</p>
<h4 id="有向图的加权邻接矩阵"><a href="#有向图的加权邻接矩阵" class="headerlink" title="有向图的加权邻接矩阵"></a>有向图的加权邻接矩阵</h4><p>设有向图具有 n 个顶点，则用 n 行 n 列的矩阵 A 表示该有向图;并且 A[i,j]  &#x3D;  a , 如果i 至 j 有一条有向边且它的权值为a。A[i,j] &#x3D; ∞,0 或其它标志；如果 i 至 j 没有一条有向边。<br>优点：判断任意两点之间是否有边方便，仅耗费 O(1) 时间。<br>缺点：即使 &lt;&lt; n2 条边，也需内存 n2 &#x2F;2 单元，太多; 仅读入数据耗费  O( n2 )  时间，太长。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><pre><code>顺序存储+链式存储
</code></pre>
<p>设有向图或无向图具有 n 个顶点，则用 顶点表、边表表示该有向图或无向图。<br>顶点表：用数组的形式存放所有的顶点。<br>边表（出边表）：从某个顶点出发的边组成的单链表。<br>优点：内存消耗 ＝  顶点数 ＋ 边数<br>缺点：确定 i –&gt; j 是否有边，最坏需耗费 O(n) 时间。无向图同一条边表示两次边表空间浪费一倍。有向图中寻找进入某结点的边，非常困难。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 数据结构复习</li>
        <li><strong>Author:</strong> GIn</li>
        <li><strong>Created at
                :</strong> 2023-11-15 21:48:20</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-01-04 23:42:32
            </li>
        
        <li>
            <strong>Link:</strong> https://redefine.ohevan.com/2023/11/15/数据结构复习/
        </li>
        <li>
            <strong>
                License:
            </strong>
            
            This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
            

        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E8%AF%BE%E5%86%85/">#课内</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                        rel="prev"
                        href="/2023/11/15/2023%E7%A7%8B-%E5%85%B3%E4%BA%8E%E5%BD%93%E4%B8%8B%E5%92%8C%E6%9C%AA%E6%9D%A5/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">2023秋_关于当下和未来</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                        rel="next"
                        href="/2023/10/10/hello-world/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Hello World</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container">
                <div class="comments-container pjax">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;Comments
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-swup-reload-script>
        import { init } from '/js/libs/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://example.example.com',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">数据结构复习</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-1-%E7%BB%AA%E8%AE%BA"><span class="nav-text">Chapter 1 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">存储结构(物理结构)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97"><span class="nav-text">运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%88%86%E6%9E%90"><span class="nav-text">算法的描述和分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">算法的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">算法的描述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">Chapter 2 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="nav-text">线性表定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">形式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">线性表的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">单链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter3-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-text">Chapter3 栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">栈的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-text">顺序栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%AE%E7%A9%BA%E6%A0%88%E7%AE%97%E6%B3%95"><span class="nav-text">置空栈算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%A0%88%E7%A9%BA%E7%AE%97%E6%B3%95"><span class="nav-text">判栈空算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E6%A0%88%E7%AE%97%E6%B3%95"><span class="nav-text">入栈算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E6%A0%88%E7%AE%97%E6%B3%95"><span class="nav-text">出栈算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%A0%88"><span class="nav-text">链栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-text">伪代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B"><span class="nav-text">栈与递归过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hanoi-tower"><span class="nav-text">Hanoi tower</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">递归实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">队列的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9C%A8%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E4%B8%8A%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-text">定义在队列结构上的基本运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%98%9F%E5%88%97"><span class="nav-text">用单链表表示的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E9%98%9F%E5%88%97"><span class="nav-text">用单循环链表定义的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%85%A5%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">循环队入队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%87%BA%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">循环队出队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">构建一个空的循环队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%85%A5%E9%98%9F%E7%AE%97%E6%B3%95-1"><span class="nav-text">循环队入队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%87%BA%E9%98%9F%E7%AE%97%E6%B3%95-1"><span class="nav-text">循环队出队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%BE%AA%E7%8E%AF%E9%98%9F%E7%A9%BA%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">判循环队空队算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A"><span class="nav-text">实验作业</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">Chapter 5 树与二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">树的结构和基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">树的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">树的基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8"><span class="nav-text">二叉树的定义与性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-text">其他函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91"><span class="nav-text">哈弗曼树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-text">树和森林</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter6-%E5%9B%BE"><span class="nav-text">Chapter6 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">图的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E5%8A%A0%E6%9D%83%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">数组+邻接矩阵&#x2F;加权邻接矩阵(顺序存储方式)</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">GIn</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/libs/anime.min.js"></script>

        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
