<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="GIn">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://Gin-lxy.github.io/2023/11/15/数据结构复习/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Chapter 1 绪论1. 基本概念1.数据  被计算机加工处理的对象。2.数据元素（记录、表目）  数据的基本单位，是数据集合中的一个个体。    一个数据元素可由若干个数据项组成3.数据对象  是性质相同的数据元素的集合，是数据的一个子集。4.数据结构  具有结构的数据元素的集合。它包括数据元素的逻辑结构、存储结构和相适应的运算。 逻辑结构数据元素之间的逻辑关系，与计算机无关。可用一个二元组">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习">
<meta property="og:url" content="https://gin-lxy.github.io/2023/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Chapter 1 绪论1. 基本概念1.数据  被计算机加工处理的对象。2.数据元素（记录、表目）  数据的基本单位，是数据集合中的一个个体。    一个数据元素可由若干个数据项组成3.数据对象  是性质相同的数据元素的集合，是数据的一个子集。4.数据结构  具有结构的数据元素的集合。它包括数据元素的逻辑结构、存储结构和相适应的运算。 逻辑结构数据元素之间的逻辑关系，与计算机无关。可用一个二元组">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gin-lxy.github.io/20210207164532306.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210207165334490.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210207165354972.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210207165435359.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210207170833949.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185653.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185759%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185809.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20191458.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204806.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204827.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E6%9D%83%E5%80%BC.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20211057.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210226145948307.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210226150421261.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-05%20182249.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-05%20183333.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-05%20183333%201.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210302161257975.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210302165922363.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210302170747202.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210302192004317.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-06%20092621.png">
<meta property="og:image" content="https://gin-lxy.github.io/Pasted%20image%2020240106093731.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210712160902234.png">
<meta property="og:image" content="https://gin-lxy.github.io/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-06%20094001.png">
<meta property="og:image" content="https://gin-lxy.github.io/20210303155246794.png">
<meta property="article:published_time" content="2023-11-15T13:48:20.000Z">
<meta property="article:modified_time" content="2024-01-06T01:45:06.148Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="课内">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gin-lxy.github.io/20210207164532306.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/source/avatar.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/source/avatar.jpg">
    <meta name="theme-color" content="#8f7ff4">
    <link rel="shortcut icon" href="/source/avatar.jpg">
    <!--- Page Info-->
    
    <title>
        
            数据结构复习 -
        
        GIn&#39;s notebook
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"gin-lxy.github.io","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"�Ƽ��Ķ�","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#8f7ff4","secondary":"#8587a7"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"GIn's notebook","subtitle":{"text":["The world is my oyster."],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":"https://github.com/Gin-lxy# your GitHub URL","instagram":null,"zhihu":null,"twitter":null,"email":"lxy15998403010@163.com# your email"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.5.0","navbar":{"auto_hide":false,"color":{"left":"#8f7ff4","right":"#8587a7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                GIn&#39;s notebook
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title">
            
                <h1 class="article-title-regular">数据结构复习</h1>
            
            </div>
            
                    
        
        
            <div class="article-header flex flex-row gap-2 items-center">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/source/avatar.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">GIn</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-11-15 21:48:20</span>
        <span class="mobile">2023-11-15 21:48:20</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-01-06 09:45:06</span>
            <span class="mobile">2024-01-06 09:45:06</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/blog/">blog</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E8%AF%BE%E5%86%85/">课内</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body">
            <h1 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 绪论"></a>Chapter 1 绪论</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>1.数据  被计算机加工处理的对象。<br>2.数据元素（记录、表目）  数据的基本单位，是数据集合中的一个个体。<br>    一个数据元素可由若干个数据项组成<br>3.数据对象  是性质相同的数据元素的集合，是数据的一个子集。<br>4.数据结构  具有结构的数据元素的集合。它包括数据元素的逻辑结构、存储结构和相适应的运算。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据元素之间的逻辑关系，与计算机无关。<br>可用一个二元组表示：Data_Structure &#x3D; (D,R)<br>    D—数据元素的有穷集合，R—D上关系的有穷集合。</p>
<h4 id="四种基本的逻辑结构"><a href="#四种基本的逻辑结构" class="headerlink" title="四种基本的逻辑结构"></a>四种基本的逻辑结构</h4><p>(1)集合结构  数据元素除了“属于同一集合”的联系之外，没有其它的关系。<br>(2)线性结构  数据元素之间存在一对一的关系。<br>(3)树型结构  数据元素之间存在一对多的关系。<br>(4)图状结构或网状结构  数据元素之间存在多对多的关系。</p>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构)"></a>存储结构(物理结构)</h3><pre><code>指数据的逻辑结构在计算机存储器中的映象表示。
</code></pre>
<p>1.数据元素的映象<br>     用二进制位(bit)的位串表示数据元素。<br>           每个数据元素的映象称为结点<br>           每个数据项的映象称为数据域<br>关系的映象<br>2.两种基本方法及其组合使用。<br>     顺序映象：以相对的存储位置表示关系<br>     链式映象：以附加信息(指针)表示关系<br>在不同的编程环境下，存储结构有不同的描述方式。用高级程序语言编程时，通常可用其提供的数据类型描述。</p>
<h4 id="数据存储方式的四种常用结构"><a href="#数据存储方式的四种常用结构" class="headerlink" title="数据存储方式的四种常用结构"></a>数据存储方式的四种常用结构</h4><p>(1)顺序存储：数据元素依次放在连续的存储单元中。<br>(2)链式存储：在存储结点中增加若干指针域，记录后继或者相关结点的地址（指针）。<br>(3)索引存储：将数据元素分为若干子表，子表的开始位置存放在索引表中。<br>(4)散列存储：根据数据元素的关键字值，由散列函数计算出存储地址。LOC(ai)&#x3D;H(key)</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>运算（操作）：在数据逻辑结构上定义的一组数据被使用的方式，其具体实现要在存储结构上进行。</p>
<p>几种常用的运算有：<br>    (1)建立数据结构              (6)检索*<br>    (2)清除数据结构              (7)更新<br>    (3)插入数据元素              (8)判空和判满*<br>    (4)删除数据元素              (9)求长*<br>    (5)排序</p>
<pre><code>操作为引用型操作，即数据值不发生变化；其它为加工型操作。
</code></pre>
<h2 id="算法的描述和分析"><a href="#算法的描述和分析" class="headerlink" title="算法的描述和分析"></a>算法的描述和分析</h2><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><pre><code>建立在数据结构基础上的、求解问题的一系列确切的步骤。
</code></pre>
<p>一个算法必须满足以下五个重要特性</p>
<ul>
<li>有穷性：对任何合法输入执行有穷步后能结束。</li>
<li>确定性：每条指令必须有确切的含义。</li>
<li>可行性：算法的每一条指令均能执行。</li>
<li>输入：有零个或多个输入。</li>
<li>输出：有一个或多个输出。</li>
</ul>
<p>评价算法优劣的基本标准:正确性 可读性 健壮性 高效性</p>
<p>算法效率的度量: 时间复杂度 空间复杂度</p>
<h3 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h3><h4 id="选择描述工具的原则"><a href="#选择描述工具的原则" class="headerlink" title="选择描述工具的原则"></a>选择描述工具的原则</h4><p>不依赖于具体计算机与具体程序设计语言的一种形式化语言，可用于描述或表达算法思想。<br>       本课程采用 C 语言<br>         特点  它描述的算法自然易懂，具有较好的可移植性。</p>
<h4 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h4><h5 id="1）时间复杂度"><a href="#1）时间复杂度" class="headerlink" title="1）时间复杂度"></a>1）时间复杂度</h5><p>算法的消耗时间：算法中每条语句执行时间之和。<br>时间复杂度：算法中各语句的频度之和T(n)。<br>                     频度—语句的执行次数；<br>                      n—问题的规模，一般为数据的输入量<br>渐近时间复杂度：当问题的规模n趋于无穷大时，T(n)的数量级(阶)。记为T(n)&#x3D;O( f(n) )。<br>     O的严格含义— 存在正的常数c和n0，使得当n$\ge$n0时, 0 $\le$ T(n) $\le$ c*f(n)<br>    实际中，将渐近时间复杂度简称为时间复杂度，用以描述算法的时间特性。</p>
<h5 id="2）空间复杂度"><a href="#2）空间复杂度" class="headerlink" title="2）空间复杂度"></a>2）空间复杂度</h5><p>算法的存储空间: 输入数据所占空间, 程序本身所占空间, 辅助变量所占空间<br>空间复杂度<br>      S(n)&#x3D;O(f(n))<br>   表示随着问题规模 n 的增大，算法运行所需存储量的增长率与 f(n) 的增长率相同。<br>存储密度<br>    d&#x3D;数据本身存储量&#x2F;实际所占存储量</p>
<h1 id="Chapter-2-线性表"><a href="#Chapter-2-线性表" class="headerlink" title="Chapter 2 线性表"></a>Chapter 2 线性表</h1><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><h3 id="形式定义"><a href="#形式定义" class="headerlink" title="形式定义"></a>形式定义</h3><p>由n (n $\neq$ 0) 个数据元素组成的有序序列。<br>Linear_list &#x3D; (D, S)<br>     其中：D&#x3D;{ai | ai $\in$D0 , i&#x3D;0,1,$\dots$ , n-1     n $\ge$ 0}<br>         R&#x3D;{N}  N&#x3D;{&lt;ai-1 , ai&gt;| ai-1 , ai $\in$D0 , i&#x3D;1,2,$\dots$ , n-1 }  D0为某个数据对象<br>         或者简记为：(a0, a1, …, ai , …an-1 )  n $\ge$ 0（n为表长。 当n&#x3D;0，称为空表）</p>
<h3 id="线性表的特点"><a href="#线性表的特点" class="headerlink" title="线性表的特点"></a>线性表的特点</h3><pre><code>在数据元素的非空有限集合
</code></pre>
<p>1,数据元素间是线性关系，数据元素在表中的位置只取决于其序号<br>2.存在唯一的一个被称作“第一个”的数据元素和唯一的一个被称作“最后一个”的数据元素<br>3.除第一个外，每个数据元素均只有一个前驱；除最后一个外，每个数据元素均只有一个后继</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct</span><br><span class="line">      &#123;   datatype  data[MAXSIZE];   </span><br><span class="line">           int  last;//最后一个元素在数组中的位置</span><br><span class="line">       &#125; SeqList;    </span><br></pre></td></tr></table></figure></div>
<p>定义一个顺序表的存储变量：<br>       SeqList L;<br>指向SeqList 类型的指针 SeqList *p; p是一个指针变量，通过“p&#x3D;(SeqList )malloc(sizeof(SeqList));”操作来获得顺序表的存储空间，p中存放的是顺序表的地址。</p>
<p>线性表的表长表示为：(*p).last＋1，或者 p-&gt;last+1<br>线性表中数据元素顺序存储的基址为：p-&gt;data<br>线性表中数据元素的存储或表示为：p-&gt;data[0] ～ p-&gt;data[p-&gt;last]</p>
<h4 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h4><pre><code>顺序表的初始化即构造一个空表，对表是一个加工型的运算，因此，将 L设为指针参数，首先动态分配存储空间，然后，将表中 last 指针置为－1，表示表中没有数据元素
</code></pre>
<p>顺序表初始化</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SeqList *init_SeqList( )</span><br><span class="line"> &#123;  </span><br><span class="line">    SeqList *p;</span><br><span class="line">    p= (SeqList *)malloc(sizeof(SeqList)); /*申请顺序表的存储空间*/</span><br><span class="line">     if  (p) </span><br><span class="line">          &#123;  p-&gt;last=-1;</span><br><span class="line">              return p; </span><br><span class="line">          &#125;        /*返回顺序表的存储地址*/       </span><br><span class="line">    else   return –1;         /*申请不成功，返回错误代码-1 */</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p> 设调用函数为主函数，主函数对初始化函数的调用如下：<br> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> main() </span><br><span class="line">&#123; </span><br><span class="line">		SeqList *L;</span><br><span class="line">         L=Init_SeqList();</span><br><span class="line">        …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h4 id="顺序表的插入算法"><a href="#顺序表的插入算法" class="headerlink" title="顺序表的插入算法"></a>顺序表的插入算法</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int Insert_SeqList(SeqList *L,int i,DataType x)</span><br><span class="line"> &#123;  int j;</span><br><span class="line">    if (L-&gt;last==MAXSIZE-1) </span><br><span class="line">      &#123;printf(&quot;表满&quot;); </span><br><span class="line">        return -1;      /*表空间已满，不能插入，返回错误代码-1*/</span><br><span class="line">      &#125; </span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;last+2) /*检查插入位置的正确性*/</span><br><span class="line">       &#123;  printf(&quot;位置错&quot;) ;</span><br><span class="line">           return 0; /*插入位置参数错，返回错误代码0 */</span><br><span class="line">        &#125; 　　</span><br><span class="line">    for (j=L-&gt;last;j&gt;=i-1;j--)</span><br><span class="line">          L-&gt;data[j+1]=L-&gt;data[j]; /*结点移动 */</span><br><span class="line">    L-&gt;data[i-1]=x;　　　　　        /*新元素插入*/</span><br><span class="line">    L-&gt;last++; 　　 /*last指向新的最后元素*/</span><br><span class="line">    return 1;　　　 /*插入成功，返回成功代码1 */</span><br></pre></td></tr></table></figure></div>
<h4 id="顺序表的删除算法"><a href="#顺序表的删除算法" class="headerlink" title="顺序表的删除算法"></a>顺序表的删除算法</h4> <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int Delete_SeqList(SeqList *L,int i)</span><br><span class="line">&#123;</span><br><span class="line"> int j;</span><br><span class="line"> if (i&lt;1 || i&gt;L-&gt;last+1)           /*检查空表及删除位置的合法性*/</span><br><span class="line">     &#123;  printf (&quot;不存在第i个元素&quot;);  </span><br><span class="line">        return 0;                  /*不能删除，返回错误代码0*/</span><br><span class="line">     &#125;</span><br><span class="line"> for (j=i;j&lt;=L-&gt;last;j++)</span><br><span class="line">   L-&gt;data[j-1]=L-&gt;data[j];        /*数据元素向前移动*/</span><br><span class="line"> L-&gt;last--;                        /* last指向新的最后元素*/</span><br><span class="line"> return 1;                         /*删除成功，返回成功代码1*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="顺序表的合并"><a href="#顺序表的合并" class="headerlink" title="顺序表的合并"></a>顺序表的合并</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void merge(SeqList *A, SeqList *B, SeqList *C)</span><br><span class="line">  &#123; </span><br><span class="line">    int i,j,k;</span><br><span class="line">    i=0; j=0; k=0;</span><br><span class="line">    while ( i&lt;=A-&gt;last &amp;&amp; j&lt;=B-&gt;last ) </span><br><span class="line">                                            /*将A和B的当前元素较小者复制到表C*/</span><br><span class="line">    if (A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">                C-&gt;data[k++]=A-&gt;data[i++];</span><br><span class="line">        else  C-&gt;data[k++]=B-&gt;data[j++];</span><br><span class="line">  while (i&lt;=A-&gt;last ) 	/*将A中剩余元素复制到表C*/</span><br><span class="line">           C-&gt;data[k++]= A-&gt;data[i++];</span><br><span class="line">  while (j&lt;=B-&gt;last )        /*将B中剩余元素复制到表C */</span><br><span class="line">           C-&gt;data[k++]=B-&gt;data[j++];</span><br><span class="line">   C-&gt;last=k-1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<h4 id="线性表的优缺点"><a href="#线性表的优缺点" class="headerlink" title="线性表的优缺点"></a>线性表的优缺点</h4><p>优点</p>
<ul>
<li>逻辑相邻，物理相邻</li>
<li>可随机存取任一元素</li>
<li>存储空间使用紧凑</li>
</ul>
<p>缺点</p>
<ul>
<li>插入、删除操作需要移动大量的元素</li>
<li>预先分配空间需按最大空间分配，利用不充分</li>
<li>表容量扩充困难</li>
</ul>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的基本概念"><a href="#单链表的基本概念" class="headerlink" title="单链表的基本概念"></a>单链表的基本概念</h3><p>在链式结构中，除了要存储数据元素的信息外，还要存储它的后继元素的存储地址。因此，为了表示每个数据元素ai与其直接后继元素ai+1之间的逻辑关系，对数据ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。我们吧把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。<br>n个结点（ai的存储映像）链结成一个链表，即为线性表（a1, a2, …, an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210207164532306.png"
                     
                ><br>把链表中第一个结点的存储位置叫做头指针。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210207165334490.png"
                     
                ><br>有时为了方便对链表进行操作，会在单链表的第一个结点前附设一个节点，称为头结点，此时头指针指向的结点就是头结点。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210207165354972.png"
                     
                ><br>空链表，头结点的直接后继为空<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210207165435359.png"
                     
                ><br>假设p是指向线性表第i个数据元素的指针，p-&gt;data表示第i个位置的数据域，p-&gt;next表示第i+1个位置的指针域，则第p+i个数据元素可表示为<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210207170833949.png"
                     
                ></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef int SLTDataType;</span><br><span class="line"> </span><br><span class="line">typedef struct SListNode</span><br><span class="line">&#123;</span><br><span class="line">	SLTDataType data;</span><br><span class="line">	struct SListNode* next;//存放下一个结点的地址</span><br><span class="line"> </span><br><span class="line">&#125;SListNode;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//打印链表</span><br><span class="line">void SListPrint(SListNode* phead);</span><br><span class="line"> </span><br><span class="line">//申请结点</span><br><span class="line">SListNode* SListBuyNode(SLTDataType x);</span><br><span class="line"> </span><br><span class="line">//因为我们是通过一个指针指向该链表的头结点，同时因为在进行插入删除操作时可能改变链表的头结点，所下面的参数需传二级指针</span><br><span class="line">//尾插</span><br><span class="line">void SListPushBack(SListNode** pphead, SLTDataType x);</span><br><span class="line"> </span><br><span class="line">//头插</span><br><span class="line">void SListPushFront(SListNode** pphead, SLTDataType x);</span><br><span class="line"> </span><br><span class="line">//尾删</span><br><span class="line">void SListPopBack(SListNode** pphead);</span><br><span class="line"> </span><br><span class="line">//头删</span><br><span class="line">void SListPopFront(SListNode** pphead);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//查找</span><br><span class="line">SListNode* SListFind(SListNode* phead, SLTDataType x);</span><br><span class="line"> </span><br><span class="line">//指定位置后面插入</span><br><span class="line">void SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x);</span><br><span class="line"> </span><br><span class="line">//指定位置后面删除</span><br><span class="line">void SListErase(SListNode** pphead, SListNode* pos);</span><br><span class="line"> </span><br><span class="line">//销毁链表</span><br><span class="line">void SListDestory(SListNode** pphead);</span><br></pre></td></tr></table></figure></div>

<h4 id="申请结点"><a href="#申请结点" class="headerlink" title="申请结点"></a>申请结点</h4><p>链表的每一个结点都是动态开辟(malloc)出来的，每一个结点的大小为该结构体的大小。<br>开辟成功后，要将结点存放的数据置为需要存放的值，结点存放的地址置为NULL。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//申请结点</span><br><span class="line">SListNode* SListBuyNode(SLTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">	SListNode* newnode = (SListNode*)malloc(sizeof(SListNode));</span><br><span class="line">	if (newnode == NULL)//判断结点是否开辟成功</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;malloc:&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;data = x;</span><br><span class="line">	newnode-&gt;next = NULL;</span><br><span class="line">	return newnode;//返回结点地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h4><p>因为不能根据下标访问元素(即不能随机访问)，当然我们也不知到最后一个结点的位置，所在尾插时，需要遍历找到最后一个结点的位置。<br>同时这里分为两种情况：</p>
<ol>
<li>如果链表为空，则直接插入即可。</li>
<li>如果链表不为空，则需要找到尾结点再插入。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//尾插</span><br><span class="line">void SListPushBack(SListNode** pphead, SLTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead);</span><br><span class="line">    SListNode* newnode = SListBuyNode(x);//申请结点</span><br><span class="line">	if (*pphead == NULL)//1.链表为空</span><br><span class="line">	&#123;</span><br><span class="line">		*pphead = newnode;//直接将头结点置为需要插入的结点</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		SListNode* cur = *pphead;</span><br><span class="line">		while (cur-&gt;next)//找尾结点</span><br><span class="line">		&#123;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		cur-&gt;next = newnode;//将尾结点中存放的地址置为插入结点的地址即可</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h4><p>头插相对来说比较简单，直接将申请结点的next置为头结点，然后将头结点改成申请结点即可<br><strong>注：这里不需要考虑链表是否为空。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//头插</span><br><span class="line">void SListPushFront(SListNode** pphead, SLTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">    assert(pphead);</span><br><span class="line">	SListNode* newnode = SListBuyNode(x);</span><br><span class="line">	newnode-&gt;next = *pphead;//将申请结点中保存的地址置为头结点的地址</span><br><span class="line">	*pphead = newnode;//再将头结点向右移动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="尾删"><a href="#尾删" class="headerlink" title="尾删"></a>尾删</h4><p>同尾插一样，我们也不知道尾结点的地址，所以需要先找到尾结点。</p>
<p>同时这里需要考虑三种情况：</p>
<ol>
<li>链表为空。</li>
<li>链表中只有一个结点。</li>
<li>链表中有一个以上结点。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//尾删</span><br><span class="line">void SListPopBack(SListNode** pphead)</span><br><span class="line">&#123;</span><br><span class="line">    //1.链表为空不能删除结点,且该指针不能为空</span><br><span class="line">	assert(*pphead &amp;&amp; phead);</span><br><span class="line"> </span><br><span class="line">    //2.链表中只有一个结点，直接释放该结点，然后将结点置为NULL</span><br><span class="line">	if ((*pphead)-&gt;next == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		free(*pphead);</span><br><span class="line">		*pphead = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //3.链表中有一个以上结点，先找尾结点，释放掉尾结点,置为NULL</span><br><span class="line">    //  但这样还不够，因为倒数第二个结点还存有尾结点的地址，所以需要将他置为NULL</span><br><span class="line">	SListNode* cur = *pphead;//用来标记倒数第二个结点</span><br><span class="line">	SListNode* next = (*pphead)-&gt;next;//标记尾结点</span><br><span class="line">	while (next-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		next = next-&gt;next;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cur-&gt;next = NULL;//将倒数第二个结点中存的地址置为NULL</span><br><span class="line">	free(next);//释放尾结点</span><br><span class="line">	next = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="头删"><a href="#头删" class="headerlink" title="头删"></a>头删</h4><p>头删也比较简单，相当于将头指针移动到第二个结点上。<br>这里分为两种情况：</p>
<ol>
<li>链表为空。</li>
<li>链表不为空。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//头删</span><br><span class="line">void SListPopFront(SListNode** pphead)</span><br><span class="line">&#123;</span><br><span class="line">	assert(*pphead &amp;&amp; phead);//链表为空不能删除</span><br><span class="line">	SListNode* next = (*pphead)-&gt;next;//记录第二个结点的地址</span><br><span class="line">	free(*pphead);//释放头结点</span><br><span class="line">	*pphead = next;//将指针指向第二个结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="指定位置后面插入"><a href="#指定位置后面插入" class="headerlink" title="指定位置后面插入"></a>指定位置后面插入</h4><p>这里在指定位置后面插入而不在前面插入是因为，在前面插入时需要找到插入位置前面的地址，而这样又会遍历一次链表，时间复杂度为O(N)，而在后面插入则直接插入即可，时间复杂度为O(1)。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//指定位置后面插入</span><br><span class="line">void SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead &amp;&amp; pos);</span><br><span class="line">	SListNode* newnode = SListBuyNode(x);//申请结点</span><br><span class="line">	SListNode* next = pos-&gt;next;//找到插入位置的下一个结点的地址</span><br><span class="line">	pos-&gt;next = newnode;//插入结点</span><br><span class="line">	newnode-&gt;next = next;//连接到后面的链表</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 在pos位置之前去插入一个节点</span><br><span class="line">void SListInsert(SLTNode** pphead, ListNode* pos, SLTDateType x)</span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead);</span><br><span class="line">	assert(pos);</span><br><span class="line"> </span><br><span class="line">	ListNode* newnode = BuyListNode(x);</span><br><span class="line">	if (*pphead == pos)</span><br><span class="line">	&#123;</span><br><span class="line">		newnode-&gt;next = *pphead;</span><br><span class="line">		*pphead = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		// 找到pos的前一个位置</span><br><span class="line">		ListNode* posPrev = *pphead;</span><br><span class="line">		while (posPrev-&gt;next != pos)</span><br><span class="line">		&#123;</span><br><span class="line">			posPrev = posPrev-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		posPrev-&gt;next = newnode;</span><br><span class="line">		newnode-&gt;next = pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="指定位置删除"><a href="#指定位置删除" class="headerlink" title="指定位置删除"></a>指定位置删除</h4><p>这里在指定位置删除，而不在前面删除或者后面删除，是因为在头删和尾删时会遇到一些麻烦。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//指定位置删除</span><br><span class="line">void SListErase(SListNode** pphead, SListNode* pos)</span><br><span class="line">&#123;</span><br><span class="line">	assert(pphead &amp;&amp; pos);</span><br><span class="line">	if (*pphead == pos)//如果头结点是要删除的结点</span><br><span class="line">	&#123;</span><br><span class="line">		*pphead = (*pphead)-&gt;next;</span><br><span class="line">		free(pos);</span><br><span class="line">		pos = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		SListNode* cur = *pphead;</span><br><span class="line">		while (cur-&gt;next != pos)//找到要删除的结点</span><br><span class="line">		&#123;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		cur-&gt;next = pos-&gt;next;//将需要删除的结点的上一个结点的next指向需要删除的下一个结点</span><br><span class="line">		free(pos);</span><br><span class="line">		pos = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>根据提供的数据，在链表中遍历每个结点，若某个结点中的数据与之相同则返回该结点的地址；若没有找到则返回NULL</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//查找</span><br><span class="line">SListNode* SListFind(SListNode* phead, SLTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">	while (phead)</span><br><span class="line">	&#123;</span><br><span class="line">		if (phead-&gt;data == x)</span><br><span class="line">		&#123;</span><br><span class="line">			return phead;</span><br><span class="line">		&#125;</span><br><span class="line">		phead = phead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="销毁链表"><a href="#销毁链表" class="headerlink" title="销毁链表"></a>销毁链表</h3><p>保存下一个结点的地址，释放当前结点，再将指针指向下一个结点，释放下一个结点，直到链表为空。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//销毁链表</span><br><span class="line">void SListDestory(SListNode** pphead)</span><br><span class="line">&#123;</span><br><span class="line">    assert(pphead);</span><br><span class="line">	while (*pphead)</span><br><span class="line">	&#123;</span><br><span class="line">		SListNode* next = (*pphead)-&gt;next;</span><br><span class="line">		free(*pphead);</span><br><span class="line">		*pphead = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Chapter3-栈与队列"><a href="#Chapter3-栈与队列" class="headerlink" title="Chapter3 栈与队列"></a>Chapter3 栈与队列</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈 是一种特殊的线性表，限定插入和删除操作只能在表尾进行。具有后进先出(LIFO—Last In First Out )的特点。<br>定义在栈结构上的基本运算<br>       (1)  生成空栈操作<br>       (2)  判栈空函数<br>       (3)  数据元素入栈操作<br>       (4)  数据元素出栈函数<br>       (5)  取栈顶元素函数<br>       (6)  置栈空操作<br>       (7)  求当前栈元素个数函数</p>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>栈的顺序存储结构<br>一个栈独占一组地址连续的存储单元<br>类型定义<br>数组(栈空间)+栈顶指示<br>    通常0下标端设为栈底，栈顶指针top值为-1，表示空栈<br>和顺序表相似，顺序栈的类型描述如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define  MAXSIZE  1024   </span><br><span class="line">typedef  struct</span><br><span class="line"> &#123;datatype  data[MAXSIZE];</span><br><span class="line"> int  top;</span><br><span class="line"> &#125;SeqStack；</span><br></pre></td></tr></table></figure></div>
<p>定义一个指向顺序栈的指针：  SeqStack  *s;</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S-&gt;top == 0 (此时出栈下溢)</span><br><span class="line">S-&gt;top==MAXSIZE -1 此时入栈上溢</span><br></pre></td></tr></table></figure></div>
<h3 id="置空栈算法"><a href="#置空栈算法" class="headerlink" title="置空栈算法"></a>置空栈算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SeqStack *Init_SeqStack()</span><br><span class="line"> &#123; SeqStack  *s;</span><br><span class="line">   s=(SeqStack *) malloc(sizeof(SeqStack)); /*申请栈空间*/</span><br><span class="line">   if (!s)</span><br><span class="line">      &#123; printf(”空间不足”\n);</span><br><span class="line">        return NULL;     /*未申请到足够大的存储空间，返回空指针*/</span><br><span class="line">      &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123; s-&gt;top=-1;         /*初始化栈顶指针*/</span><br><span class="line">      return s;             /*申请到栈空间，返回栈空间地址*/</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="判栈空算法"><a href="#判栈空算法" class="headerlink" title="判栈空算法"></a>判栈空算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Empty_SeqStack(SeqStack *s)</span><br><span class="line">&#123;  if (s-&gt;top==-1)</span><br><span class="line">    return 1;    /*空栈返回1*/，</span><br><span class="line">  else</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="入栈算法"><a href="#入栈算法" class="headerlink" title="入栈算法"></a>入栈算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int Push_SeqStack(SeqStack *s,datatype  x)</span><br><span class="line">  &#123;  if (s-&gt;top==MAXSIZE-1)</span><br><span class="line">          return 0;         /*栈满不能入栈，返回错误代码0*/</span><br><span class="line">     else</span><br><span class="line">        &#123; s-&gt;top++;       /*栈顶指针向上移动*/</span><br><span class="line">          s-&gt;data[s-&gt;top]=x; /*将x至入新的栈顶*/</span><br><span class="line">          return 1;                 /*入栈成功，返回成功代码1 */</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="出栈算法"><a href="#出栈算法" class="headerlink" title="出栈算法"></a>出栈算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Pop_SeqStack(SeqStack *s,datatype *x)</span><br><span class="line"> &#123;  /*通过*x返回原栈顶元素*/</span><br><span class="line">    if (Empty_SeqStack(s))</span><br><span class="line">     return 0;       /*栈空不能出栈，返回错误代码0*/</span><br><span class="line">    else</span><br><span class="line">         &#123; *x=s-&gt;data[s-&gt;top];   /*保存栈顶元素值*/</span><br><span class="line">             s-&gt;top--;     /*栈顶指针向下移动*/</span><br><span class="line">            return 1;     /*返回成功代码1 */</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>思考：n个元素依次入栈，可得到多少个合法的出栈序列<br>     (2n)!&#x2F;[(n+1)!*n! ]<br>不同的出栈序列实际上对应着不同的入栈出栈操作，以1记为入栈，0为出栈。则问题实际上是求n个1和n个0构成的全排列，其中任意一个位置，它及它此前的数中，1个个数要大于等于0的个数。n个1和n个0构成的全排列数为：(2n)!&#x2F;[n!*n! ]<br>在n个0和n个1构成的2n个数的序列中，假设第一次出现0的个数大于1个个数（即0的个数比1的个数大一）的位置为k，则k为奇数，k之前有相等数目的0和1，各为(k-1)&#x2F;2.  若把这k个数，0换成1，1换成0 ，则原序列唯一对应上一个n＋1个1和n－1个0的序列。反之，任意一个由n＋1个1和n－1个0构成的序列也唯一的对应一个这样不合要求的序列。由于一一对应，故这样不合要求的序列数实际上等于有n＋1个1和n－1个0构成的排列数，即(2n)!&#x2F;(n+1)(n-1)。<br>因此合法的个数为：(2n)!&#x2F;[n!<em>n! ]- (2n)!&#x2F;[(n+1)!</em>(n-1)! ]&#x3D; (2n)!&#x2F;[(n+1)!*n! ] </p>
</blockquote>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>链式栈无栈满问题，空间可扩充</li>
<li>插入与删除仅在栈顶处执行</li>
<li>链式栈的栈顶在链头</li>
<li>适合于多栈操作</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct node</span><br><span class="line">     &#123; datatype data;</span><br><span class="line">       struct node *next;</span><br><span class="line">   &#125;StackNode，* LinkStack;</span><br><span class="line">    定义top为栈顶指针：   LinkStack  top ;</span><br></pre></td></tr></table></figure></div>
<p>栈中的主要运算是在栈顶插入、删除，显然在链表的头部做栈顶是最方便的。<br>链栈基本操作的实现如下：</p>
<p>置空栈<br>    仅是需要将栈顶指针置为空即可。</p>
<h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Empty_LinkStack(LinkStack top)  </span><br><span class="line">&#123; if (top==NULL) return 1;     </span><br><span class="line">     else return 0;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Push_LinkStack(LinkStack top, datatype x)</span><br><span class="line">&#123; StackNode *p;</span><br><span class="line">   p=(StackNode *)malloc(sizeof(StackNode));</span><br><span class="line">   p-&gt;data=x; </span><br><span class="line">   p-&gt;next=top;</span><br><span class="line">   top=p;</span><br><span class="line">   return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LinkStack Pop_LinkStack (LinkStack top, datatype *x)</span><br><span class="line">  &#123;  StackNode *p;</span><br><span class="line">     if (top==NULL) return NULL;</span><br><span class="line">     else &#123;*x= top-&gt;data;</span><br><span class="line">               p=top;  </span><br><span class="line">               top=top&gt;next;</span><br><span class="line">               free (p);</span><br><span class="line">               return top;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="栈与递归过程"><a href="#栈与递归过程" class="headerlink" title="栈与递归过程"></a>栈与递归过程</h2><p>递归的含义<br>    函数、过程或者数据结构的内部又直接或者间接地由自身定义。</p>
<p>适合于应用递归的场合<br>规模较大的问题可以化解为规模较小的问题，且二者处理(或定义)的方式一致；<br>当问题规模降低到一定程度时是可以直接求解的(终止条件)</p>
<h3 id="Hanoi-tower"><a href="#Hanoi-tower" class="headerlink" title="Hanoi tower"></a>Hanoi tower</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void Hanoi(int n,char a,char b,char c)</span><br><span class="line">&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return ;</span><br><span class="line">    Hanoi(n-1,a,c,b);</span><br><span class="line">    printf(&quot;Move disk %d from %c to %c\n&quot;,n,a,c);</span><br><span class="line">    Hanoi(n-1,b,c,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    Hanoi(n,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="递归实现原理"><a href="#递归实现原理" class="headerlink" title="递归实现原理"></a>递归实现原理</h3><p>利用栈，栈中每个元素称为工作记录，分成三个部分：</p>
<ul>
<li>返回地址  实在参数表(变参和值参)   局部变量</li>
<li>发生调用时，保护现场，即当前的工作记录入栈，然后<br> 转入被调用的过程</li>
<li>一个调用结束时，恢复现场，即若栈不空，则退栈，从<br> 退出的返回地址处继续执行下去</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><pre><code>是一种特殊的线性表，限定插入和删除操作分别在表的两端进行。具有先进先出(FIFO—First In First Out)的特点。
</code></pre>
<h3 id="定义在队列结构上的基本运算"><a href="#定义在队列结构上的基本运算" class="headerlink" title="定义在队列结构上的基本运算"></a>定义在队列结构上的基本运算</h3><p>(1)构造空队列操作<br>(2)判队空否函数<br>(3)元素入队操作<br>(4)元素出队函数<br>(5)取队头元素函数<br>(6) 队列置空操作<br>(7)求队中元素个数函数</p>
<blockquote>
<p>进队时队尾指针先进一  rear &#x3D; rear + 1，再将新元素按 rear 指示位置加入。<br>出队时队头指针先进一 front &#x3D; front + 1，再将front指示 的元素取出。<br>队满时再进队将溢出出错；队空时再出队将队空处理。</p>
</blockquote>
<h3 id="用单链表表示的队列"><a href="#用单链表表示的队列" class="headerlink" title="用单链表表示的队列"></a>用单链表表示的队列</h3><pre><code>队头指针 + 队尾指针
</code></pre>
<ul>
<li>队头在链头，队尾在链尾。</li>
<li>链式队列在进队时无队满问题，但有队空问题。</li>
<li>队空条件为 front -&gt;next&#x3D;&#x3D; NULL</li>
</ul>
<h3 id="用单循环链表定义的队列"><a href="#用单循环链表定义的队列" class="headerlink" title="用单循环链表定义的队列"></a>用单循环链表定义的队列</h3><pre><code>队尾指针
</code></pre>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><pre><code> 将顺序队列的存储区假想为一个环状空间
</code></pre>
<p> 类型定义:一维数组(队列空间) + 头指针 + 尾指针<br>队头指针front指向队头元素的前一位置，而队尾指针rear指向队尾元素.<br>优点：不需要移动元素，操作效率高，空间的利用率也很高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct     &#123; </span><br><span class="line">      datatype data[MAXSIZE];      /*数据的存储区*/</span><br><span class="line">      int front,rear;         /*队头队尾指针*/</span><br><span class="line">      int num;                /*队中元素的个数*/</span><br><span class="line">    &#125;c_SeQueue;          /*循环队*/</span><br><span class="line"></span><br><span class="line">c_SeQueue *q;</span><br></pre></td></tr></table></figure></div>
<p>存储队列的数组被当作首尾相接的表处理。<br>为解决如何判断队列的满与空问题：牺牲一个存储单元 。<br>队头、队尾指针加1时从maxSize -1直接进到0，可用语言的取模(余数)运算实现。<br>出队: q -&gt;front &#x3D; (q -&gt; front + 1) % maxSize;<br>入队:  q-&gt;rear &#x3D; (q-&gt; rear + 1) % maxSize;<br>队列初始化： q-&gt; front &#x3D; q-&gt; rear &#x3D; 0;<br>队空条件： q-&gt; front &#x3D;&#x3D; q-&gt; rear;<br>队满条件：(q-&gt; rear + 1) % maxSize &#x3D;&#x3D; q-&gt; front</p>
<blockquote>
<p>思考：循环队列中当前元素的个数为多少？<br>当前元素个数(q-&gt;rear- q-&gt; front+maxsize)%maxsize</p>
</blockquote>
<h3 id="循环队入队算法"><a href="#循环队入队算法" class="headerlink" title="循环队入队算法"></a>循环队入队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int In_SeQueue ( CSeQueue *q , datatype  x)</span><br><span class="line">&#123;  if(q-&gt;num==MAXSIZE)</span><br><span class="line">    &#123; printf(&quot;队满&quot;);</span><br><span class="line">      return -1;        /*队满不能入队*/</span><br><span class="line">     &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123; q&gt;rear=(q-&gt;rear+1) % MAXSIZE;</span><br><span class="line">      q-&gt;data[q-&gt;rear]=x;</span><br><span class="line">      q-&gt;num++;</span><br><span class="line">      return 1;    	/*入队完成*/</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环队出队算法"><a href="#循环队出队算法" class="headerlink" title="循环队出队算法"></a>循环队出队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Out_SeQueue (CSeQueue *q, datatype *x)</span><br><span class="line">  &#123;if (q-&gt;num==0)</span><br><span class="line">        &#123; printf(&quot;队空&quot;)；</span><br><span class="line">          return -1;   	             /*队空不能出队*/</span><br><span class="line">        &#125;</span><br><span class="line"> else &#123;q-&gt;front=(q-&gt;front+1) % MAXSIZE;</span><br><span class="line">          *x=q-&gt;data[q-&gt;front]; 	/*读出队头元素*/</span><br><span class="line">           q-&gt;num--; </span><br><span class="line">          return 1;                           /*出队完成*/</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="构建一个空的循环队算法"><a href="#构建一个空的循环队算法" class="headerlink" title="构建一个空的循环队算法"></a>构建一个空的循环队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSeQueue* Init_SeQueue()</span><br><span class="line"> &#123; CSeQueue *q;</span><br><span class="line">    q=(CSeQueue *)malloc(sizeof(CSeQueue));</span><br><span class="line">    q-&gt;front=q-&gt;rear=MAXSIZE-1;</span><br><span class="line">    q-&gt;num=0;</span><br><span class="line">    return q;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环队入队算法-1"><a href="#循环队入队算法-1" class="headerlink" title="循环队入队算法"></a>循环队入队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int In_SeQueue ( CSeQueue *q , datatype  x)</span><br><span class="line">&#123;  if(q-&gt;num==MAXSIZE)</span><br><span class="line">    &#123; printf(&quot;队满&quot;);</span><br><span class="line">      return -1;        /*队满不能入队*/</span><br><span class="line">     &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123; q&gt;rear=(q-&gt;rear+1) % MAXSIZE;</span><br><span class="line">      q-&gt;data[q-&gt;rear]=x;</span><br><span class="line">      q-&gt;num++;</span><br><span class="line">      return 1;    	/*入队完成*/</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="循环队出队算法-1"><a href="#循环队出队算法-1" class="headerlink" title="循环队出队算法"></a>循环队出队算法</h3>  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Out_SeQueue (CSeQueue *q, datatype *x)</span><br><span class="line">    &#123;if (q-&gt;num==0)</span><br><span class="line">          &#123; printf(&quot;队空&quot;)；</span><br><span class="line">            return -1;   	             /*队空不能出队*/</span><br><span class="line">          &#125;</span><br><span class="line">   else &#123;q-&gt;front=(q-&gt;front+1) % MAXSIZE;</span><br><span class="line">            *x=q-&gt;data[q-&gt;front]; 	/*读出队头元素*/</span><br><span class="line">             q-&gt;num--; </span><br><span class="line">            return 1;                           /*出队完成*/</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="判循环队空队算法"><a href="#判循环队空队算法" class="headerlink" title="判循环队空队算法"></a>判循环队空队算法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Empty_SeQueue(CSeQueue *q)</span><br><span class="line">  &#123;  if (q&gt;num==0)  return 1;</span><br><span class="line">     else  return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="实验作业"><a href="#实验作业" class="headerlink" title="实验作业"></a>实验作业</h2><p>利用栈实现如下两种类型的进制转换：<br>（1）十进制转换为二进制；<br>（2）二进制转换为十进制。<br>要求：从键盘输入要转换的十进制数或二进制数，如输入的为十进制数则以‘$’结束，如输入的为二进制数则以‘#’结束。利用结束符‘$’‘#’自动识别要做的转换类型，并将对应的转换结果输出。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> @author 李昕烨 2022213259</span><br><span class="line"> 2023/11/12*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">struct Stack</span><br><span class="line">&#123;</span><br><span class="line">    int top;</span><br><span class="line">    int cap;</span><br><span class="line">    int* array;</span><br><span class="line">&#125;;</span><br><span class="line">struct Stack* init(int cap)</span><br><span class="line">&#123;</span><br><span class="line">    struct Stack* stack=(struct Stack*)malloc(sizeof(struct Stack));</span><br><span class="line">    stack-&gt;cap=cap;</span><br><span class="line">    stack-&gt;top=-1;</span><br><span class="line">    stack-&gt;array=(int*)malloc(stack-&gt;cap*sizeof(int));</span><br><span class="line">&#125;</span><br><span class="line">int full(struct Stack* stack)</span><br><span class="line">&#123;</span><br><span class="line">    return stack-&gt;top==stack-&gt;cap-1;</span><br><span class="line">&#125;</span><br><span class="line">int empty(struct Stack* stack)</span><br><span class="line">&#123;</span><br><span class="line">    return stack-&gt;top==-1;</span><br><span class="line">&#125;</span><br><span class="line">void push(struct Stack* stack, int num) &#123;</span><br><span class="line">    if (!full(stack))</span><br><span class="line">        stack-&gt;array[++stack-&gt;top] = num;</span><br><span class="line">&#125;</span><br><span class="line">int pop(struct Stack* stack) &#123;</span><br><span class="line">    if (!empty(stack))</span><br><span class="line">        return stack-&gt;array[stack-&gt;top--];</span><br><span class="line">    return -1; // 栈为空，返回错误值</span><br><span class="line">&#125;</span><br><span class="line">//二进制转10进制</span><br><span class="line">int todemical(char *num)</span><br><span class="line">&#123;</span><br><span class="line">    /*int temp=0;</span><br><span class="line">    int k=1;</span><br><span class="line">    int p=2;</span><br><span class="line">    while(num!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=temp+(num%10)*2*k;</span><br><span class="line">        num=num/10;</span><br><span class="line">        k=p;</span><br><span class="line">        printf(&quot;%d&quot;, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;*/</span><br><span class="line">     int decimalNum = 0;</span><br><span class="line">    int len = strlen(num);</span><br><span class="line">    int base = 1;</span><br><span class="line">    for (int i = len - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (num[i] == &#x27;1&#x27;)</span><br><span class="line">            decimalNum += base;</span><br><span class="line">        base *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return decimalNum;</span><br><span class="line">&#125;</span><br><span class="line">void tobinary(int num)</span><br><span class="line">&#123;</span><br><span class="line">     struct Stack* stack = init(32); // 假定最多32位二进制数</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        push(stack, num % 2);</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Binary Result: &quot;);</span><br><span class="line">    while (!empty(stack))</span><br><span class="line">        printf(&quot;%d&quot;, pop(stack));</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    free(stack-&gt;array);</span><br><span class="line">    free(stack);</span><br><span class="line">&#125;</span><br><span class="line">bool test(int result)</span><br><span class="line">&#123;</span><br><span class="line">    while(result&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(result%10&gt;2)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        result=result/10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char input[100];</span><br><span class="line">    int result;</span><br><span class="line">    printf(&quot;Enter a number (use &#x27;$&#x27; for decimal and &#x27;#&#x27; for binary): &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, input);</span><br><span class="line">     if (input[strlen(input) - 1] == &#x27;$&#x27;) &#123;</span><br><span class="line">        input[strlen(input) - 1] = &#x27;\0&#x27;; // 移除 &#x27;$&#x27; 结束符</span><br><span class="line">        result = atoi(input); // 将字符串转换为整数</span><br><span class="line">        tobinary(result);// 十进制转二进制</span><br><span class="line">    &#125; else if (input[strlen(input) - 1] == &#x27;#&#x27;) &#123;</span><br><span class="line">        input[strlen(input) - 1] = &#x27;\0&#x27;; // 移除 &#x27;#&#x27; 结束符</span><br><span class="line">        result = atoi(input);</span><br><span class="line">        int t=result;</span><br><span class="line">        if(!test(result))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Invalid input format.\n&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        result=todemical(input); // 二进制转十进制</span><br><span class="line">        printf(&quot;Demical result: %d&quot;, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Invalid input format.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Chapter-5-树与二叉树"><a href="#Chapter-5-树与二叉树" class="headerlink" title="Chapter 5 树与二叉树"></a>Chapter 5 树与二叉树</h1><h2 id="树的结构和基本操作"><a href="#树的结构和基本操作" class="headerlink" title="树的结构和基本操作"></a>树的结构和基本操作</h2><pre><code> 树是一类重要的非线性数据结构，是以分支关系定义的层次结构。
</code></pre>
<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树是由n(n $\ge$ 0)个结点组成的有限集合T，非空树满足：<br>    1)有一个称之为根(root)的结点。<br>    2)除根以外的其余结点被分成m(0 $\le$ m&lt;n)个互不相交的集合T1,T2 ,$\cdots$,Tm,其中每一个集合本身又是一棵树，且称为根的子树。</p>
<h3 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h3><pre><code>  除根结点外，每个结点都仅有一个前趋(父)结点
</code></pre>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>结点的度    结点拥有的子树数目。</li>
<li>叶子(终端)结点    度为0的结点。</li>
<li>分支(非终端)结点    度不为0的结点。</li>
<li>树的度    树的各结点度的最大值。</li>
<li>内部结点    除根结点之外的分支结点。</li>
<li>双亲与孩子(父与子)结点    结点的子树的根称为该结点的孩子；该结点称为孩子的双亲。</li>
<li>兄弟    属于同一双亲的孩子。</li>
<li>结点的祖先    从根到该结点所经分支上的所有结点。</li>
<li>结点的子孙    该结点为根的子树中的任一结点。</li>
<li>结点的层次   表示该结点在树中的相对位置。根为第一层，其它的结点依次下推；若某结点在第L层上，则其孩子在第L+1层上。</li>
<li>堂兄弟   双亲在同一层的结点互为堂兄弟。</li>
<li>树的深(高)度   树中结点的最大层次。</li>
<li>有序树   树中各结点的子树从左至右是有次序的，不能互换。否则，称为无序树。</li>
<li>路径长度   从树中某结点Ni出发，能够“自上而下地”通过树中结点到达结点Nj，则称Ni到Nj存在一条路径，路径长度等于这两个结点之间的分支数。</li>
<li>树的路径长度   从根到每个结点的路径长度之和。</li>
<li>森林   是m(m $\ge$ 0)棵互不相交的树的集合。</li>
</ol>
<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p>1)初始化操作                  initiate(T)<br>2)求根函数                      root(T) &#x2F; root(x)<br>3)求双亲函数                  parent(T,x)<br>4)求孩子结点函数          child(T,x,i)<br>5)求右兄弟函数              right_sibling(T,x)<br>6)建树函数                      crt_tree(x,F)<br>7)插入子树操作              ins_child(y,i,x)<br>8)删除子树操作              del_child(x,i)<br>9)遍历操作                      traverse(T)<br>10)清除结构操作            clear(T)</p>
<h2 id="二叉树的定义与性质"><a href="#二叉树的定义与性质" class="headerlink" title="二叉树的定义与性质"></a>二叉树的定义与性质</h2><h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>二叉树是n(n $\ge$ 0)个结点的有限集合，它或为空树(n&#x3D;0)，或由一个根结点和两棵互不相交的左子树和右子树的二叉树组成。</p>
<h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><ul>
<li>定义是递归</li>
<li>的0$\le$结点的度$\le$ 2</li>
<li>是有序树</li>
</ul>
<h4 id="两种特殊的二叉树"><a href="#两种特殊的二叉树" class="headerlink" title="两种特殊的二叉树"></a>两种特殊的二叉树</h4><p>   - 满二叉树   每一层上的结点数都是最大结点数。<br>   - 完全二叉树   只有最下面两层结点的度可小于2，而最下一层的叶结点集中在左边若干位置上。</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>性质1   二叉树的第i层上至多有2i-1(i $\ge$ 1)个结点。<br>性质2   深度为k的二叉树至多有2k-1个结点(k $\ge$ 1)。<br>性质3   对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2 ，则n0 &#x3D; ${n}^{2}$ +1;<br>性质4   具有n个结点的完全二叉树的深度为$\lfloor \log_{2}{n} \rfloor$+1。<br>性质5   一棵具有n个结点的完全二叉树(又称顺序二叉树)，对其结点按层从上至下(每层从左至右)进行1至n的编号，则对任一结点i(1in)有：<br>    (1)若i&gt;1，则i的双亲是$\lfloor i&#x2F;2 \rfloor$；若i&#x3D;1，则i是根，无双亲。<br>    (2)若2$\le$i$\le$n，则i的左孩子是2i；否则， i无左孩子。<br>    (3)若2i+1$\le$n，则i的右孩子是2i+1；否则， i无右孩子。</p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>完全二叉树：按完全二叉树编号存放<br>三元组：存储结点数据和左、右孩子在向量中的序号<br>双亲：存储结点数据和其父结点的序号<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453.png"
                     
                ></p>
<h4 id="二叉链表的类型定义"><a href="#二叉链表的类型定义" class="headerlink" title="二叉链表的类型定义"></a>二叉链表的类型定义</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef </span><br><span class="line">struct btnode&#123;</span><br><span class="line">  btnode *lchild,rchild;</span><br><span class="line">  elemtp  data;</span><br><span class="line">&#125; BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></div>
<p>定义指针变量，用来存放根结点地址，通常用该指针标识一个二叉树<br>BiTree root;</p>
<h4 id="三叉链表的类型定义"><a href="#三叉链表的类型定义" class="headerlink" title="三叉链表的类型定义"></a>三叉链表的类型定义</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">struct btnode&#123;</span><br><span class="line"> btnode *lchild,rchild;</span><br><span class="line"> btnode *parent;</span><br><span class="line"> elemtp  data;</span><br><span class="line">&#125; *BiTree;</span><br></pre></td></tr></table></figure></div>

<p>若要建立不带头结点的二叉树，可描述如下：<br>建立一棵空的不带头结点的二叉树</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BiTree Initiate ()     /*初始建立一棵空的不带头结点的二叉树*/</span><br><span class="line">     &#123;  BiTNode  *bt;</span><br><span class="line">        bt=NULL;</span><br><span class="line">        return bt;</span><br><span class="line">     &#125;</span><br><span class="line">在主函数中，可以通过如下方式调用Initiate函数：</span><br><span class="line">main ( )</span><br><span class="line">  &#123;BiTree t ;        /*定义根结点指针变量*/</span><br><span class="line">    t =Initiate ();</span><br><span class="line">     ……</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="Create-x，lbt，rbt"><a href="#Create-x，lbt，rbt" class="headerlink" title="Create(x，lbt，rbt)"></a>Create(x，lbt，rbt)</h4><p>生成一棵以x为根结点的数据域值以lbt和rbt为左右子树的二叉树。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BiTree Create(elemtype x, BiTree lbt, BiTree rbt) </span><br><span class="line">  &#123;BiTree  p;</span><br><span class="line">   if((p=(BiTNode*)malloc(sizeof(BiTNode)))==NULL) </span><br><span class="line">       return NULL;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    p-&gt;lchild=lbt;</span><br><span class="line">    p-&gt;rchild=rbt; </span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="InsertL-bt-x-parent"><a href="#InsertL-bt-x-parent" class="headerlink" title="InsertL(bt, x, parent)"></a>InsertL(bt, x, parent)</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20183453%201.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    BiTree InsertL(BiTree bt，elemtype x，BiTree parent)</span><br><span class="line">      &#123;BiTree  p;</span><br><span class="line">       if (parent==NULL)</span><br><span class="line">        &#123;printf(&quot;\n插入出错&quot;)；</span><br><span class="line">         return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">      if ((p=(BiTNode *)malloc(sizeof(BiTNode)))==NULL) return NULL;</span><br><span class="line">      p-&gt;data=x;</span><br><span class="line">      p-&gt;lchild=NULL;</span><br><span class="line">      p-&gt;rchild=NULL;</span><br><span class="line">      if (parent-&gt;lchild==NULL) parent-&gt;lchild=p;</span><br><span class="line">      else &#123;p-&gt;lchild=parent-&gt;lchild;</span><br><span class="line">               parent-&gt;lchild=p;</span><br><span class="line">              &#125;</span><br><span class="line">      return bt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>InsertR(bt，x，parent)：功能类同于 InsertL(bt, x, parent) ，算法略。</p>
<h4 id="DeleteL-bt，parent"><a href="#DeleteL-bt，parent" class="headerlink" title="DeleteL(bt，parent)"></a>DeleteL(bt，parent)</h4><pre><code>在二叉树bt中删除parent的左子树
</code></pre>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> BiTree  DeleteL(BiTree bt，BiTree parent) </span><br><span class="line">     &#123; BiTree  p;</span><br><span class="line">        if (parent==NULL||parent-&gt;lchild==NULL)</span><br><span class="line">          &#123; printf(&quot;\n删除出错&quot;)；</span><br><span class="line">            return NULL;</span><br><span class="line">          &#125;</span><br><span class="line">        p=parent-&gt;lchild;</span><br><span class="line">        parent-&gt;lchild=NULL;</span><br><span class="line">        free(p);  </span><br><span class="line"> /*当*p为非叶子结点时，这样删除仅释放了所删子树根结点的空间，*/</span><br><span class="line">/*若要删除子树分支中的结点，需用后面介绍的遍历操作来实现。*/</span><br><span class="line">        return bt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p> DeleteR(bt，parent)：算法略。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ol>
<li>遍历的目的 非线性结构Þ线性结构</li>
<li>遍历的概念  指按某条搜索路线走遍二叉树的每个结点，使得树中每个结点都被访问一次，且仅被访问一次。</li>
<li>典型的遍历方法</li>
</ol>
<ul>
<li>先(根)序遍历  DLR</li>
<li>中(根)序遍历  LDR</li>
<li>后(根)序遍历  LRD</li>
<li>层序遍历</li>
</ul>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185653.png"
                     
                ></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185759%201.png"
                     
                ></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20185809.png"
                     
                ></p>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><blockquote>
<p>队列实现:遍历从根结点开始，首先将根结点入队，然后开始执行循环:结点出队、访问该结点、其左右儿子入队<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20191458.png"
                     
                ></p>
</blockquote>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204806.png"
                     
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20204827.png"
                     
                ></p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="构建二叉树的二叉链表"><a href="#构建二叉树的二叉链表" class="headerlink" title="构建二叉树的二叉链表"></a>构建二叉树的二叉链表<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.png"
                     
                ></h4><h4 id="在二叉树中查找结点值为x的结点"><a href="#在二叉树中查找结点值为x的结点" class="headerlink" title="在二叉树中查找结点值为x的结点"></a>在二叉树中查找结点值为x的结点</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void  pre_find(BiTree bt, ElemType x, BiTree &amp;q)//用q返回</span><br><span class="line">&#123; //F是全局bool型变量，初值为FALSE</span><br><span class="line">    if (bt &amp;&amp; F==FALSE)</span><br><span class="line">     &#123;</span><br><span class="line">          if (bt-&gt;data==x)</span><br><span class="line">          &#123;   q=bt; F=TRUE;&#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;  pre_find(bt-&gt;lchild, x, q);</span><br><span class="line">               pre_find(bt-&gt;rchild, x, q)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="求二叉树中每个结点所处的层次"><a href="#求二叉树中每个结点所处的层次" class="headerlink" title="求二叉树中每个结点所处的层次"></a>求二叉树中每个结点所处的层次</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void  pre_level(BiTree p, int level)</span><br><span class="line">&#123;    </span><br><span class="line">       if (p)</span><br><span class="line">       &#123; </span><br><span class="line">            write(p-&gt;data, level);//实现时可用printf代替</span><br><span class="line">            pre_level(p-&gt;lchild; level+1);</span><br><span class="line">            pre_level(p-&gt;rchild; level+1);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void  pre_height(BiTree p, int level)</span><br><span class="line">&#123;     if (p)</span><br><span class="line">       &#123;  if (h&lt;level)   h=level;</span><br><span class="line">           pre_height(p-&gt;lchild, level+1);</span><br><span class="line">           pre_height(p-&gt;rchild,level+1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void  post_height(BiTree bt,int &amp;h)</span><br><span class="line">&#123;     if (bt==NULL) h=0</span><br><span class="line">       else</span><br><span class="line">       &#123; post_height(bt-&gt;lchild, h1);</span><br><span class="line">          post_height(bt-&gt;rchild,h2);</span><br><span class="line">          h:=1+max(h1,h2);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="复制一颗二叉树"><a href="#复制一颗二叉树" class="headerlink" title="复制一颗二叉树"></a>复制一颗二叉树</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void  pre_copy(BiTree bt; BiTree &amp;q)</span><br><span class="line">&#123;   </span><br><span class="line">    if (bt) </span><br><span class="line">     &#123;      new(q); </span><br><span class="line">            q-&gt;data= bt-&gt;data;</span><br><span class="line">             pre_copy(bt-&gt;lchild, q-&gt;lchild);</span><br><span class="line">             pre_copy(bt-&gt;rchild, q-&gt;rchild);</span><br><span class="line">      &#125;</span><br><span class="line">     else  </span><br><span class="line">           q=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h3><ul>
<li>树的路径长度   从树根到每一个结点的路径上的分支数。</li>
<li>带权路径长度   结点的路径长度与该结点的权之积。</li>
<li>树的带权路径长度   树中所有叶子结点的带权路径长度之和。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E6%9D%83%E5%80%BC.png"
                     
                ></li>
<li>最优二叉树(哈夫曼树)   带权路径长度WPL最小的二叉树。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-04%20211057.png"
                     
                ></li>
</ul>
<h4 id="哈夫曼树的应用"><a href="#哈夫曼树的应用" class="headerlink" title="哈夫曼树的应用"></a>哈夫曼树的应用</h4><h5 id="最佳判定树"><a href="#最佳判定树" class="headerlink" title="最佳判定树"></a>最佳判定树</h5><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><blockquote>
<p>用于通信和数据传送中字符的二进制编码，可以使电文编码总长度最短<br>   左右分支分别为0,1<br>   字符在叶节点上</p>
</blockquote>
<ul>
<li>哈夫曼编码是不等长编码</li>
<li>哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀</li>
<li>哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1</li>
<li>发送过程：根据由哈夫曼树得到的编码表送出字符数据</li>
<li>接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束</li>
</ul>
<h5 id="哈夫曼编码系统"><a href="#哈夫曼编码系统" class="headerlink" title="哈夫曼编码系统"></a>哈夫曼编码系统</h5><p>[问题描述]<br>设计一个利用哈夫曼算法的编码系统，能完成以下基本要求。<br>[基本要求]<br>（1）键盘输入长为n的字符串， 统计其中每个字符的权值（出现频次），建立哈夫曼树；<br>（2）编码：利用建好的哈夫曼树生成哈夫曼编码；<br>（3）输出编码（在屏幕上显示）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct node *parent,*left,*right;</span><br><span class="line">	int frequency;</span><br><span class="line">&#125; Node,*huffman;</span><br><span class="line"></span><br><span class="line">//初始化树</span><br><span class="line">Node *create(char data, int frequency)</span><br><span class="line">&#123;</span><br><span class="line">	Node *new=(Node *)malloc(sizeof(Node));</span><br><span class="line">	new-&gt;data=data;</span><br><span class="line">	new-&gt;frequency=frequency;</span><br><span class="line">	new-&gt;left=NULL;</span><br><span class="line">	new-&gt;right=NULL;</span><br><span class="line">	new-&gt;parent=NULL;</span><br><span class="line">	return new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构建Huffman树</span><br><span class="line">huffman build(char data[],int freq[],int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	Node *nodes=(Node *)malloc(sizeof(Node)*(size)*2);</span><br><span class="line">	int index[50];//使用索引数组进行排序</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; 2 * size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		nodes[i] = *create(data[i], freq[i]);</span><br><span class="line">		index[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int k = 0; k &lt; size - 1; k++)//选择排序,按照频率大小排序</span><br><span class="line">	&#123;</span><br><span class="line">		int min, temp;</span><br><span class="line">		for (int i = 2 * k; i &lt; size + k - 1; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			min = i;</span><br><span class="line">			for (int j = i + 1; j &lt; size + k; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (nodes[index[j]].frequency &lt; nodes[index[min]].frequency)</span><br><span class="line">				&#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = index[min];</span><br><span class="line">			index[min] = index[i];</span><br><span class="line">			index[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		Node *n_parent = (Node *) malloc(sizeof(Node));  //创建父节点</span><br><span class="line">        n_parent-&gt;frequency = nodes[index[2 * k]].frequency + nodes[index[2 * k + 1]].frequency;  </span><br><span class="line">        n_parent-&gt;left = &amp;nodes[index[2 * k]];</span><br><span class="line">        n_parent-&gt;right = &amp;nodes[index[2 * k + 1]];</span><br><span class="line">        nodes[index[2 * k]].parent = n_parent;</span><br><span class="line">        nodes[index[2 * k + 1]].parent = n_parent;</span><br><span class="line">        n_parent-&gt;data = &#x27;$&#x27;;  // 父节点数据随意设置，这里使用&#x27;$&#x27;表示 </span><br><span class="line">		nodes[index[size + k]] = *n_parent;</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;nodes[index[2 * size - 2]];</span><br><span class="line">&#125;</span><br><span class="line">void find(huffman root, char code[], int top, char chara)</span><br><span class="line">&#123;</span><br><span class="line">	if (root-&gt;left != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		code[top] = &#x27;0&#x27;;</span><br><span class="line">		find(root-&gt;left, code, top + 1, chara);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root-&gt;right != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		code[top] = &#x27;1&#x27;;</span><br><span class="line">		find(root-&gt;right, code, top + 1, chara);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; root-&gt;data == chara)</span><br><span class="line">	&#123;//打印字符和对应Huffman编码</span><br><span class="line">		printf(&quot;%c: &quot;, root-&gt;data);</span><br><span class="line">		for (int i = 0; i &lt; top; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%c&quot;, code[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char str[1005];</span><br><span class="line">	int freque[128]= &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	memset(str, &#x27;\0&#x27;, sizeof(str));</span><br><span class="line">	memset(freque, 0, sizeof(freque));</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%s&quot;, str);//输入字符串</span><br><span class="line"></span><br><span class="line">	int len = strlen(str);//计算字符频率</span><br><span class="line">	for(int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		freque[(int)str[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	char data[200];</span><br><span class="line">	int freq[200], flag[200], size = 0;</span><br><span class="line">	memset(flag, 0, sizeof(flag));</span><br><span class="line">	//记录字符和对应频率</span><br><span class="line">	for(int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(flag[(int)str[i]] == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[(int)str[i]] = 1;</span><br><span class="line">			freq[size] = freque[(int)str[i]];</span><br><span class="line">			data[size] = str[i];</span><br><span class="line">			size++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	huffman root = build(data, freq, size);</span><br><span class="line">	char code[100];  // 适当设置编码的最大长度</span><br><span class="line">	memset(code, &#x27;\0&#x27;, sizeof(code));</span><br><span class="line">	//输出每个字符Huffman编码</span><br><span class="line">	for(int i = 0; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		find(root, code, 0, data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h4><pre><code> 树转换为二叉树的规则:每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。
</code></pre>
<ol>
<li>在兄弟结点之间加一连线;</li>
<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉;</li>
<li>以树根为轴心，顺时针旋转45°。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210226145948307.png"
                     
                ></li>
</ol>
<h4 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h4><p>森林是由若干棵树组成的，所以完全可以理解为,森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。<br>森林转换成二叉树的画法:</p>
<ol>
<li>将森林中的每棵树转换成相应的二叉树;</li>
<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线;</li>
<li>以第一棵树的根为轴心顺时针旋转45°。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210226150421261.png"
                     
                ></li>
</ol>
<h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><ul>
<li>先序遍历   先访问树的根结点，然后依次先根遍历根的每棵子树       ABEFCDG(二叉树先序)</li>
<li>后序遍历   先依次后根遍历根的每棵子树，然后访问树的根结点       EFBCGDA(二叉树中序)</li>
</ul>
<h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><h5 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h5><blockquote>
<p>访问第一棵树的根结点；先序遍历第一棵树的根的子树森林； 先序遍历除第一棵树外; 剩余的树构成的森林（逐棵先序遍历每棵子树&#x2F;  对应二叉树的先序遍历)<br> <br> ##### 中序遍历<br>中序遍历第一棵树的根的子树森林;访问第一棵树的根结点;中序遍历第一棵树外剩余的树构成的森林(逐棵后序遍历每棵子树&#x2F;对应二叉树的中序遍历)</p>
</blockquote>
<h1 id="Chapter6-图"><a href="#Chapter6-图" class="headerlink" title="Chapter6 图"></a>Chapter6 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><pre><code>  非线性结构，数据元素之间呈多对多的关系。
</code></pre>
<p>图的定义<br>Graph&#x3D;(V,E)<br>    V：顶点(数据元素)的有穷非空集合。<br>    E：边的有穷集合。<br>图的相关术语<br>顶点   数据元素所构成的结点。<br>无向图   边的顶点偶对是无序的。<br>                (vi, vj)和(vj, vi)代表同一条边(i $\ge$ j)。<br>有向图   边的顶点偶对是有序的。<br>                有向边&lt; vi, vj &gt;也称为弧。<br>                 vi是弧尾&#x2F;初始点； vj是弧头&#x2F;终端点。<br>(无向)完全图   每个顶点与其余顶点都有边的无向图。<br>                 顶点数为n时，边数e&#x3D;n(n-1)&#x2F;2<br>有向完全图   每个顶点与其余顶点都有弧的有向图。<br>                 顶点数为n时，弧数e&#x3D;n(n-1)<br>思考：一无向图的顶点个数为n，则该图最多有（  n(n-1)&#x2F;2  ）条边。<br>稀疏图   有很少边或弧的图。<br>稠密图   有较多边或弧的图。<br>权   图中的边或弧具有一定的大小的概念。<br>网   边&#x2F;弧带权的图。<br>邻接   有边&#x2F;弧相连的两个顶点之间的关系。<br>            存在(vi, vj)，则称vi和vj互为邻接点；<br>              存在&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi<br>关联(依附)   边&#x2F;弧与顶点之间的关系。<br>            存在(vi, vj)&#x2F; &lt;vi, vj&gt;， 则称该边&#x2F;弧关联于vi和vj<br>子图   对于图G&#x3D;(V,E)和G’&#x3D;(V’,E’)，如果V’V，E’ E，且E’关联的顶点都在V’中，则称G’是G的子图。<br>生成子图   由图的全部顶点和部分边组成的子图称为原图的生成子图。<br>顶点的度   与该顶点相关联的边的数目，记为D(v)。<br>入度ID(v)：有向图中，以该顶点为弧头的弧数目。<br>出度OD(v)：有向图中，以该顶点为弧尾的弧数目。<br>顶点数n、边数e和度数之间的关系:<br>$e&#x3D;\frac{1}{2} \sum_{i&#x3D;1}^{n} D\left ( vi \right )$<br>思考：<br>在一个无向图中，所有顶点的度数之和等于所有边数2倍，<br>在一个有向图中，所有顶点的入度之和等于所有顶点出度之和的1倍。<br>在有n个顶点的有向图中，每个顶点的度最大可达2(n-1)。<br>路径   接续的边构成的顶点序列。<br>路径长度   路径上边或弧的数目&#x2F;权值之和。<br>回路(环)   第一个顶点和最后一个顶点相同的路径。<br>简单路径   除路径起点和终点可以相同外，其余顶点均不相同的路径。<br>简单回路(简单环)   除路径起点和终点相同外，其余项点均不相同的路径。<br>n个顶点的无向完全图中,两个顶点之间简单路径数目为多少？<br>1 + A(n-2,1) + A(n-2,2) + … + A(n-2,n-2)其中A(m,n)是m取n的排列数。<br>连通图   无向图中，任何一对顶点间都存在路径。<br>连通分量   无向图中的极大连通子图。<br>思考：n个顶点组成的连通无向图，其边的个数至少为n-1。<br>思考：一个有n个结点的无向图，最少有（ 1 ）个连通分量，<br>最多有（n）个连通分量。<br>若G是一个非连通无向图，共有28条边，则该图至少有_9_个顶点。<br>生成树   包含图中全部顶点的极小连通子图<br>有向树   图中恰有一个顶点入度为0，其余顶点入度均为1。<br>生成森林   有向图中，包含所有顶点的若干棵有向树构成的子图。</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="数组-邻接矩阵-加权邻接矩阵-顺序存储方式"><a href="#数组-邻接矩阵-加权邻接矩阵-顺序存储方式" class="headerlink" title="数组+邻接矩阵&#x2F;加权邻接矩阵(顺序存储方式)"></a>数组+邻接矩阵&#x2F;加权邻接矩阵(顺序存储方式)</h3><h4 id="无权值的有向图的邻接矩阵"><a href="#无权值的有向图的邻接矩阵" class="headerlink" title="无权值的有向图的邻接矩阵"></a>无权值的有向图的邻接矩阵</h4><p> 设有向图具有 n 个顶点，则用 n 行 n 列的布尔矩阵 A 表示该有向图;并且 A[i,j]  &#x3D;  1 , 如果i 至 j 有一条有向边；A[i,j] &#x3D; 0如果 i 至 j 没有一条有向边。<br> 注意： 顶点i出度: i行之和。顶点i入度: i列之和。</p>
<h4 id="无权值的无向图的邻接矩阵"><a href="#无权值的无向图的邻接矩阵" class="headerlink" title="无权值的无向图的邻接矩阵"></a>无权值的无向图的邻接矩阵</h4><p>设无向图具有 n 个顶点，则用 n 行 n 列的布尔矩阵 A 表示该无向图；并且 A[i,j]  &#x3D;  1 , 如果i 至 j 有一条无向边；A[I,j] &#x3D; 0如果 i 至 j 没有一条无向边。<br>i结点的度: i行或i列之和。<br>必然为对称矩阵，可压缩为上三角矩阵或下三角矩阵。<br>思考：n个顶点的连通图用邻接矩阵表示时,该矩阵至少有2(n-1)个非零元素。<br>n个顶点的强连通图用邻接矩阵表示时,该矩阵至少有n个非零元素</p>
<h4 id="有向图的加权邻接矩阵"><a href="#有向图的加权邻接矩阵" class="headerlink" title="有向图的加权邻接矩阵"></a>有向图的加权邻接矩阵</h4><p>设有向图具有 n 个顶点，则用 n 行 n 列的矩阵 A 表示该有向图;并且 A[i,j]  &#x3D;  a , 如果i 至 j 有一条有向边且它的权值为a。A[i,j] &#x3D; ∞,0 或其它标志；如果 i 至 j 没有一条有向边。<br>优点：判断任意两点之间是否有边方便，仅耗费 O(1) 时间。<br>缺点：即使 &lt;&lt; $n^{2}$ 条边，也需内存 $n^{2}$ &#x2F;2 单元，太多; 仅读入数据耗费  O( $n^{2}$  )  时间，太长。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><pre><code>顺序存储+链式存储
</code></pre>
<p>设有向图或无向图具有 n 个顶点，则用 顶点表、边表表示该有向图或无向图。<br>顶点表：用数组的形式存放所有的顶点。<br>边表（出边表）：从某个顶点出发的边组成的单链表。<br>优点：内存消耗 ＝  顶点数 ＋ 边数。<br>缺点：确定 i –&gt; j 是否有边，最坏需耗费 O(n) 时间。无向图同一条边表示两次边表空间浪费一倍。有向图中寻找进入某结点的边，非常困难。<br>顶点表中的结点的表示： 用数组</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="right">firstarc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">data:顶点的数据域，保存顶点的数据元素的值。</td>
<td align="right"></td>
</tr>
<tr>
<td align="center">firstarc:顶点的指针域，指向自该顶点出发的的第一条边的边表结点地址。</td>
<td align="right"></td>
</tr>
<tr>
<td align="center">（出）边表中的结点的表示：</td>
<td align="right"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">info</th>
<th>adjvex</th>
<th>nextarc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">info:边结点的数据场，保存边的权值等。</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">adjvex:边结点的指针，给出本条边依附的另一顶点（非出发顶点）的地址。</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">nextarc:顶点的指针，给出自该顶点出发的的下一条边的 边结点的地址。</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-05%20182249.png"
                     
                ></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">邻接矩阵适合稠密图 邻接表适合稀疏图</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="图的遍历两种遍历方式"><a href="#图的遍历两种遍历方式" class="headerlink" title="图的遍历两种遍历方式"></a>图的遍历两种遍历方式</h2><p>深度优先遍历 (树的先根遍历的推广)<br>广度优先遍历 (树的按层次遍历的推广)</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>注意：每个顶点只能被访问一次，因为一个顶点可以和其它的任何顶点相邻接，为了避免对一个顶点的重复访问，必须对访问过的顶点加以标记。顶点的邻接顶点的次序是任意的，因此深度优先搜索的序列可能有多种。<br>遍历过程</p>
<ol>
<li>选中第一个被访问的顶点。</li>
<li>对顶点作已访问过的标志。</li>
<li>依次从顶点的未被访问过、 邻接顶点出发，进行深度优先遍历,转向2。</li>
<li>如果还有顶点未被访问，则选中一个起始顶点，转向2。</li>
<li>所有的顶点都被访问到，则结束。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-05%20183333.png"
                     
                ><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];	//访问标记数组</span><br><span class="line">/*从顶点出发，深度优先遍历图G*/</span><br><span class="line">void DFS(Graph G, int v)&#123;</span><br><span class="line">	int w;</span><br><span class="line">	visit(v);	//访问顶点</span><br><span class="line">	visited[v] = TRUE;	//设已访问标记</span><br><span class="line">	//FirstNeighbor(G,v):求图G中顶点v的第一个邻接点，若有则返回顶点号，否则返回-1。</span><br><span class="line">	//NextNeighbor(G,v,w):假设图G中顶点w是顶点v的一个邻接点，返回除w外顶点v</span><br><span class="line">	for(w = FirstNeighbor(G, v); w&gt;=0; w=NextNeighor(G, v, w))&#123;</span><br><span class="line">		if(!visited[w])&#123;	//w为u的尚未访问的邻接顶点</span><br><span class="line">			DFS(G, w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*对图进行深度优先遍历*/</span><br><span class="line">void DFSTraverse(MGraph G)&#123;</span><br><span class="line">	int v; </span><br><span class="line">	for(v=0; v&lt;G.vexnum; ++v)&#123;</span><br><span class="line">		visited[v] = FALSE;	//初始化已访问标记数据</span><br><span class="line">	&#125;</span><br><span class="line">	for(v=0; v&lt;G.vexnum; ++v)&#123;	//从v=0开始遍历</span><br><span class="line">		if(!visited[v])&#123;</span><br><span class="line">			DFS(G, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h4><p>    主要操作：查找每个顶点的所有邻接点</p>
<ul>
<li>邻接矩阵   O(n2)</li>
<li>邻接表   无向图  O(n+2e)有向图  O(n+e)<blockquote>
<p>思考：如果对于图而言，深度优先遍历可以判断其是否有环吗？<br>可以。 dfs（v）结束前出现顶点u到v的回边，则图中必有包含顶点v和u的回路</p>
</blockquote>
</li>
</ul>
<h4 id="非递归的算法思想"><a href="#非递归的算法思想" class="headerlink" title="非递归的算法思想"></a>非递归的算法思想</h4><p>(1)访问一个顶点，并记录它已被访问；将它的所有未访问的邻接顶点入栈；<br>(2)如果栈空，则退出；否则，栈中一顶点出栈；<br>(3)如果该顶点已被访问过，则转(2)否则，转(1)<br>非递归的算法实现]<br>void  Traver(AdjList g,vertype v)<br>  &#x2F;&#x2F;图g以邻接表为存储结构，算法从顶点v开始实现非递归深度优先遍历。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;struct arc *stack[];</span><br><span class="line">   visited[v]=1；printf(v);  //输出顶点v</span><br><span class="line">   top=0; p=g[v].firstarc; stack[++top]=p;</span><br><span class="line">   while(top&gt;0 || p!=NULL)</span><br><span class="line">     &#123;</span><br><span class="line">        while (p) </span><br><span class="line">             if (p &amp;&amp; visited[p-&gt;adjvex]) p=p-&gt;next;</span><br><span class="line">            else &#123;printf(p-&gt;adjvex); visited[p-&gt;adjvex]=1; </span><br><span class="line">                 stack[++top]=p; p=g[p-&gt;adjvex].firstarc;&#125;//else</span><br><span class="line">        if (top&gt;0) &#123;p=stack[top--]; p=p-&gt;next; &#125;</span><br><span class="line">     &#125;//while  </span><br><span class="line">&#125;//算法结束。</span><br></pre></td></tr></table></figure></div>
<p>算法讨论： 以上算法适合连通图，若是非连通图，则再增加一个主调算法,其核心语句是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (vi=1;vi&lt;=n;vi++) if (!visited[vi]) Traver(g,vi);</span><br></pre></td></tr></table></figure></div>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h4 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h4><p>1、选中第一个被访问的结点 V<br>2、对结点 V 作已访问过的标志。<br>3、依次从结点 V 的未被访问过的第一个、第二个、第三个……第 M个邻接结点 W1 、W2、W3…… Wm ，且进行标记。<br>4、依次访问结点 W1 、W2、W3…… Wm的邻接结点，且进行标记。<br>5、如果还有结点未被访问，则选中一个起始结点，也标记为V，转向2。<br>6、所有的结点都被访问到，则结束。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-05%20183333%201.png"
                     
                ></p>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ol>
<li>访问顶点v，并记录它已被访问； 顶点v入队列；</li>
<li>如果队列空，则退出；否则，从队中取出一顶点；</li>
<li>求该顶点的一个邻接点；如果此邻接点未被访问，则访问它，并记录它已被访问，将其入队列；</li>
<li>如果该顶点还有下一个邻接点，则转(3);否则，转(2)<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void BFSTraverse(MGraph G)&#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	Queue Q;</span><br><span class="line">	for(i = 0; i&lt;G,numVertexes; i++)&#123;</span><br><span class="line">		visited[i] = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	InitQueue(&amp;Q);	//初始化一辅助用的队列</span><br><span class="line">	for(i=0; i&lt;G.numVertexes; i++)&#123;</span><br><span class="line">		//若是未访问过就处理</span><br><span class="line">		if(!visited[i])&#123;</span><br><span class="line">			vivited[i] = TRUE;	//设置当前访问过</span><br><span class="line">			visit(i);	//访问顶点</span><br><span class="line">			EnQueue(&amp;Q, i);	//将此顶点入队列</span><br><span class="line">			//若当前队列不为空</span><br><span class="line">			while(!QueueEmpty(Q))&#123;</span><br><span class="line">				DeQueue(&amp;Q, &amp;i);	//顶点i出队列</span><br><span class="line">				//FirstNeighbor(G,v):求图G中顶点v的第一个邻接点，若有则返回顶点号，否则返回-1。</span><br><span class="line">				//NextNeighbor(G,v,w):假设图G中顶点w是顶点v的一个邻接点，返回除w外顶点v</span><br><span class="line">				for(j=FirstNeighbor(G, i); j&gt;=0; j=NextNeighbor(G, i, j))&#123;</span><br><span class="line">					//检验i的所有邻接点</span><br><span class="line">					if(!visited[j])&#123;</span><br><span class="line">						visit(j);	//访问顶点j</span><br><span class="line">						visited[j] = TRUE;	//访问标记</span><br><span class="line">						EnQueue(Q, j);	//顶点j入队列</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="算法时间复杂度分析-1"><a href="#算法时间复杂度分析-1" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h4><p>主要操作：查找每个顶点的所有邻接点<br>邻接矩阵   O($n^{2}$ )<br>邻接表   无向图  O(n+2e) 有向图  O(n+e)</p>
<blockquote>
<p>已知一无向图G&#x3D;（V，E），其中V&#x3D;{a,b,c,d,e } E&#x3D;{(a,b),(a,d),(a,c),(d,c),(b,e)}现用某一种图遍历方法从顶点a开始遍历图，得到的序列为abecd，则采用的是______遍历方法。</p>
</blockquote>
<blockquote>
<p>假设以邻接矩阵作为图的存储结构，编写算法判别在给定的有向图中是否存在一个简单有向回路，若存在，则以顶点序列的方式输出该回路（找到一条即可）。（注：图中不存在顶点到自己的弧）</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void find_cycle() //判断是否有回路，有则输出邻接矩阵。visited数组为全局变量。</span><br><span class="line">     &#123;for (i=1;i&lt;=n;i++) visited[i]=0;</span><br><span class="line">      for (i=1;i&lt;=n;i++ ) if (!visited[i])  dfs(i);</span><br><span class="line">&#125;//find_cycle</span><br><span class="line">void dfs(int v)</span><br><span class="line">&#123;   visited[v]=1;</span><br><span class="line">    for(j=1;j&lt;=n;j++ ) </span><br><span class="line">         if (g[v][j]!=0) //存在边(v,j)</span><br><span class="line">              if (visited[j]!=1) &#123;if (!visited[j]) dfs(j); &#125;</span><br><span class="line">              else &#123;cycle=1; Print(j,j);&#125;</span><br><span class="line">    visited[v]=2;</span><br><span class="line">&#125;</span><br><span class="line">void  Print(int v,int start )  //输出从顶点start开始的回路。</span><br><span class="line">&#123;for(i=1;i&lt;=n;i++)</span><br><span class="line">    if(g[v][i]!=0 &amp;&amp; visited[i]==1 )  //若存在边（v,i），且顶点i的状态为1。</span><br><span class="line">      &#123;printf(“%d”,v); if(i==start) printf(“\n”); else Print(i,start);break;&#125;//if</span><br><span class="line">    &#125;//Print</span><br></pre></td></tr></table></figure></div>
<pre><code>有向图判断回路要比无向图复杂。利用深度优先遍历，将顶点分成三类：未访问；已访问但其邻接点未访问完;已访问且其邻接点已访问完。用0，1，2表示这三种状态。若dfs（v）结束前出现顶点u到v的回边，则图中必有包含顶点v和u的回路。对应程序中v的状态为1，而u是正访问的顶点，若我们找出u的下一邻接点的状态为1，就可以输出回路了。
</code></pre>
<h3 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h3><h4 id="无向图的连通分量和生成树"><a href="#无向图的连通分量和生成树" class="headerlink" title="无向图的连通分量和生成树"></a>无向图的连通分量和生成树</h4><h5 id="连通图的生成树"><a href="#连通图的生成树" class="headerlink" title="连通图的生成树"></a>连通图的生成树</h5><ol>
<li>生成树是图G的一个子图，该子图是包含G的所有顶点的树(或者是自由树—未确定根结点)。</li>
<li>若图G有n个顶点，则其生成树必具有n-1条边。</li>
<li>生成树是包含图中所有顶点的极小连通子图。</li>
<li>生成树可以通过对图的深度&#x2F;广度优先遍历而得到，称之为深度&#x2F;广度优先生成树。<br>  在算法中，访问一个结点时vj，同时记录它的父结点vi，(vi ,vj)是生成树的一条边。<br>一般情况，BFS(广度优先搜索)生成树的树高小于DFS(深度优先搜索)生成树的高度。<br>一个图的生成树是不唯一的</li>
</ol>
<ul>
<li>从不同的顶点出发</li>
<li>采用不同的存储结构和存储顺序</li>
</ul>
<h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><pre><code>由一个网络（带权图）生成的各边的权数总和最小的生成树称为最小生成树，记为MST。
</code></pre>
<p>MST性质：设N&#x3D;(V,{E})是一个连通的带权图，U是V的真子集，若边(u,v)[u ${\in }$ U,v${\in }$V-U]是E中所有一个端点在U内，一个端点不在U内的边中权值最小的一条边(轻边)，则一定存在G的一棵生成树包括此边。</p>
<blockquote>
<p>证明：假定存在一棵不包括边  ( u, v ) 在内的最小代价生成树，设其为 T。将边( u, v )添加到树 T ，则形成一条包含  ( u, v ) 的回路。因此，必定存在另一条边  ( u‘ ，v‘  ) ，且 u’ 属于 U , v ‘   属于 V - U。删去边 ( u‘   ，v‘  ) ，得到另一棵生成树 T ‘  ; 因为边 ( u, v ) 的代价小于边  ( u‘   ，v‘  ) 的代价，所以新的生成树T ‘将是代价最小的树。和原假设矛盾。  <br> 注：新的生成树T‘是树的理由：连通且无回路。</p>
</blockquote>
<h4 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h4><p>Prim算法构造最小生成树的过程如下图所示。初始时从图中任取一顶点(如顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。<br>通俗点说就是：从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210302161257975.png"
                     
                ></p>
<h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>1)初始化closedge[v](v&#x3D;1..n)                                 O(n)<br>2)重复n-1次以下操作：<br>  2.1)在closedge[v](v&#x3D;1..n)中选择最小且非0的  lowcost，记录其v值(设为k)和相应的vex；                     O( ${n}^{2}$ )<br>  2.2)输出该边(vex,k)；                                        O(n)<br>  2.3)顶点k并入U集：closedge[k].lowcost&#x3D;0；  O(n)<br>  2.4)调整候选边集closedge[v](v&#x3D;1..n)：          O( ${n}^{2}$ )<br>   若gn[k,v] &lt; closedge[v].lowcost，<br>   则更改closedge[v]：vex&#x3D;k, lowcost&#x3D;gn[k,v]  O( ${n}^{2}$ )<br>算法特点   适用于稠密图</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*Prim算法生成最小生成树*/</span><br><span class="line">void MiniSpanTree_Prim(G)&#123;</span><br><span class="line">	int min, i, j, k;</span><br><span class="line">	int adjvex[MAXVEX];	//保存相关顶点下标</span><br><span class="line">	int lowcost[MAXVEX];	//保存相关顶点间边的权值</span><br><span class="line">	lowcost[0] = 0;	//初始化第一个权值为0，即v0加入生成树</span><br><span class="line">	//lowcost的值为0，在这里就是此下标的顶点已经加入生成树</span><br><span class="line">	adjvex[0] = 0;	//初始化第一个顶点下标为0</span><br><span class="line">	for(i=1; i&lt;G.numVertexes; i++)&#123;</span><br><span class="line">		lowcost[i] = G.arc[0][i];	//将v0顶点与之组成边的权值存入数组</span><br><span class="line">		adjvex[i] = 0;	//初始化都为v0的下标</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=1; i&lt;G.numVertexes; i++)&#123;</span><br><span class="line">		min = INFINITY;	//初始化最下权值为∞，通常设置一个不可能的很大的数字</span><br><span class="line">		j = 1; k = 0;</span><br><span class="line">		//循环全部顶点</span><br><span class="line">		while(j &lt; G.numVertexes)&#123;</span><br><span class="line">			//如果权值不为0且权值小于min</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)&#123;</span><br><span class="line">				min = lowcost[j];	//则让当前权值成为最小值</span><br><span class="line">				k = j;	//将当前最小值的下标存入k</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		print(&quot;(%d, %d)&quot;, adjvex[k], k);	//打印当前顶点边中权值的最小边</span><br><span class="line">		for(j=1; j&lt;G.numvertexes; j++)&#123;</span><br><span class="line">			//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值</span><br><span class="line">			if(lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;</span><br><span class="line">				lowcost[j] = G.arc[k][j];	//将较小权值存入lowcost</span><br><span class="line">				adjvex[j] = k;	//将下标为k的顶点存入adjvex</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h4><p>与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</p>
<p>Kruskal算法构造最小生成树的过程如下图所示。初始时为只有n个顶点而无边的非连通图T &#x3D; V , T&#x3D; {V, {}}T&#x3D;V,，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T TT，否则舍弃此边而选择下一条权值最小的边。以此类推，直至T TT中所有顶点都在一个连通分量上。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210302165922363.png"
                     
                ></p>
<h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>1)初始化T：顶点集&#x3D;所有顶点，每个独立的顶点作为一棵树，边集&#x3D;ø；                                                         O(n)</li>
<li>依权值递增序对图G的边排序，结果为E[1..e]    O(elge)</li>
<li>依次检测E中的各边(u,v)：                                    O(elge)<br> 3.1) 若u和v分属于T中两棵不同的树，则将该边加入T，并合并u和v分属的两棵树<br> 3.2) 若T中所有顶点尚未属于一棵树，转3)<br>算法特点   适用于稀疏图<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*对边集数组Edge结构的定义*/</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int begin;</span><br><span class="line">	int end;</span><br><span class="line">	int weight;</span><br><span class="line">&#125;Edge;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210302170747202.png"
                     
                ><br>于是Kruskal算法代码如下，左侧数字为行号。其中MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*Kruskar算法生成最小生成树*/</span><br><span class="line">void MiniSpanTree_Kruskal(MGraph G)&#123;</span><br><span class="line">	int i, n, m;</span><br><span class="line">	Edge edges[MAXEDGE];	//定义边集数组</span><br><span class="line">	int parent[MAXVEX];	//定义一数组用来判断边与边是否形成环路</span><br><span class="line">	/*此处省略将邻接矩阵G转化为边集数组edges并按照权由小到大排序的代码*/</span><br><span class="line">	for(i=0; i&lt;G.numVertexes; i++)&#123;</span><br><span class="line">		parent[i] = 0;	//初始化数组为0</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=0; i&lt;G.numVertexes; i++)&#123;</span><br><span class="line">		n = Find(parent, edges[i].begin);</span><br><span class="line">		m = Find(parent, edge[i],end);</span><br><span class="line">		/*假如n与m不等，说明此边没有与现有生成树形成环路*/</span><br><span class="line">		if(n != m)&#123;</span><br><span class="line">		/*将此边的结尾顶点放入下标为起点的parent中</span><br><span class="line">		表示此顶点已经在生成树集合中*/</span><br><span class="line">		parent[n] = m;</span><br><span class="line">		printf(&quot;(%d, %d, %d)&quot;, edges[i].begin, </span><br><span class="line">						edges[i].end, edges[i].weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*查找连线顶点的尾部下标*/</span><br><span class="line">int Find(int *parent, int f)&#123;</span><br><span class="line">	while(parent[f] &gt; 0)&#123;</span><br><span class="line">		f = parent[f];</span><br><span class="line">	&#125;</span><br><span class="line">	return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法用于构建单源点的最短路径—，即图中某个点到任何其他点的距离都是最短的。例如，构建地图应用时查找自己的坐标离某个地标的最短距离。可以用于有向图，但是不能存在负权值。<br>我们以上图为例，通俗点说，这个迪杰斯特拉(Dijkstra) 算法，它并不是一下子求出了$v_{0}$到$v_{8}$ 的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。<br>Dijkstra算法设置一个集合S记录已求得的最短路径的顶点。<br>在构造的过程中还设置了个辅助数组:<br>dist[]：记录从源点$v_{0}$到其他各顶点当前的最短路径长度，它的初态为：若从$v_{0}$ ​到$v_{i}$​;有弧，则dist[i]为弧上的权值；否则置dist[i]为∞ 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210302192004317.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-06%20092621.png"
                     
                ></p>
<h3 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h3><p>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：</p>
<p>矩阵D记录顶点间的最小路径<br>例如D[0][3]&#x3D; 10，说明顶点0 到 3 的最短路径为10；<br>矩阵P记录顶点间最小路径中的中转点<br>例如P[0][3]&#x3D; 1 说明，0 到 3的最短路径轨迹为：0 -&gt; 1 -&gt; 3。<br>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和 D[v][k] + D[k][w] 最小值，如果D[v][k] + D[k][w] 为更小值，则把D[v][k] + D[k][w] 覆盖保存在D[v][w]中。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Pasted%20image%2020240106093731.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXN 10 </span><br><span class="line">#define INF = 1000</span><br><span class="line"></span><br><span class="line">typedef struct struct_graph&#123;</span><br><span class="line">    char vexs[MAXN];</span><br><span class="line">    int vexnum;//顶点数 </span><br><span class="line">    int edgnum;//边数 </span><br><span class="line">    int matirx[MAXN][MAXN];//邻接矩阵 </span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line">int pathmatirx[MAXN][MAXN];//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2 </span><br><span class="line">int shortPath[MAXN][MAXN];//记录顶点间的最小路径值</span><br><span class="line"></span><br><span class="line">void short_path_floyd(Graph G, int P[MAXN][MAXN], int D[MAXN][MAXN])&#123;</span><br><span class="line">    int v, w, k;</span><br><span class="line">    //初始化floyd算法的两个矩阵 </span><br><span class="line">    for(v = 0; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        for(w = 0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">            D[v][w] = G.matirx[v][w];</span><br><span class="line">            P[v][w] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里是弗洛伊德算法的核心部分 </span><br><span class="line">    //k为中间点 </span><br><span class="line">    for(k = 0; k &lt; G.vexnum; k++)&#123;</span><br><span class="line">        //v为起点 </span><br><span class="line">        for(v = 0 ; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">            //w为终点 </span><br><span class="line">            for(w =0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">                if(D[v][w] &gt; (D[v][k] + D[k][w]))&#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];//更新最小路径 </span><br><span class="line">                    P[v][w] = P[v][k];//更新最小路径中间顶点 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n初始化的D矩阵\n&quot;);</span><br><span class="line">    for(v = 0; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        for(w = 0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;, D[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n初始化的P矩阵\n&quot;);</span><br><span class="line">    for(v = 0; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        for(w = 0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">            printf(&quot;%d&quot;, P[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = 0;</span><br><span class="line">    w = 3;</span><br><span class="line">    //求 0 到 3的最小路径</span><br><span class="line">    printf(&quot;\n%d -&gt; %d 的最小路径为：%d\n&quot;, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];</span><br><span class="line">    printf(&quot;path: %d&quot;, v);//打印起点</span><br><span class="line">    while(k != w)&#123;</span><br><span class="line">        printf(&quot;-&gt; %d&quot;, k);//打印中间点</span><br><span class="line">        k = P[k][w]; </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;-&gt; %d\n&quot;, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int v, w;</span><br><span class="line">    Graph G;</span><br><span class="line">    printf(&quot;请输入顶点数:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;G.vexnum);</span><br><span class="line">    printf(&quot;请输入初始矩阵值：\n&quot;);</span><br><span class="line">    for(v = 0; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        for(w = 0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;G.matirx[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n输入的矩阵值：\n&quot;);</span><br><span class="line">    for(v = 0; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        for(w = 0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;, G.matirx[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    short_path_floyd(G, pathmatirx, shortPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210712160902234.png"
                     
                ></p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-06%20094001.png"
                     
                ><br>二、算法<br>对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤:</p>
<ol>
<li>从AOV网中选择一个没有前驱的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为起点的有向边。</li>
<li>重复1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环(回路)，不是AOV网。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/20210303155246794.png"
                     
                ><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool TopologicalSort(Graph G)&#123;</span><br><span class="line">	InitStack(S);	//初始化栈，存储入度为0的顶点</span><br><span class="line">	for(int i=0; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">		if(indegree[i] == 0)&#123;</span><br><span class="line">			Push(S, i);	//将所有入度为0的顶点进栈</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int count = 0;	//计数，记录当前已经输出的顶点数</span><br><span class="line">	while(!IsEmpty(S))&#123;	//栈不空，则存在入度为0的顶点</span><br><span class="line">		Pop(S, i);	//顶点元素出栈</span><br><span class="line">		printf(&quot;%d &quot;, i);	//输出顶点i</span><br><span class="line">		count++;</span><br><span class="line">		for(p=G.vertices[i].finstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">			//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S</span><br><span class="line">			v = p-&gt;adjvex;</span><br><span class="line">			if(!--indegree[v])&#123;</span><br><span class="line">				Push(S, v);	//入度为0，则入栈</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(count &lt; G.vexnum)&#123;</span><br><span class="line">		return false;	//输出顶点少了，有向图中有回路，排序失败</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return true;	//拓扑排序成功</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
由于输出每个顶点的同时还要删除以它为起点的边，故拓扑排序的时间复杂度为O ( V + E ) O(V+E)O(V+E)。<br>此外，利用深度优先遍历也可实现拓扑排序。</li>
</ol>
<p>用拓扑排序算法处理AOV网时，应注意以下问题:</p>
<ol>
<li>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</li>
<li>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。</li>
<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。</li>
</ol>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 数据结构复习</li>
        <li><strong>Author:</strong> GIn</li>
        <li><strong>Created at
                :</strong> 2023-11-15 21:48:20</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-01-06 09:45:06
            </li>
        
        <li>
            <strong>Link:</strong> https://redefine.ohevan.com/2023/11/15/数据结构复习/
        </li>
        <li>
            <strong>
                License:
            </strong>
            
            This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
            

        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E8%AF%BE%E5%86%85/">#课内</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                        rel="prev"
                        href="/2023/11/15/2023%E7%A7%8B-%E5%85%B3%E4%BA%8E%E5%BD%93%E4%B8%8B%E5%92%8C%E6%9C%AA%E6%9D%A5/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">2023秋_关于当下和未来</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                        rel="next"
                        href="/2023/10/10/hello-world/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Hello World</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container">
                <div class="comments-container pjax">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;Comments
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-swup-reload-script>
        import { init } from '/js/libs/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://example.example.com',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">数据结构复习</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-1-%E7%BB%AA%E8%AE%BA"><span class="nav-text">Chapter 1 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">存储结构(物理结构)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97"><span class="nav-text">运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%88%86%E6%9E%90"><span class="nav-text">算法的描述和分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">算法的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">算法的描述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">Chapter 2 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="nav-text">线性表定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">形式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">线性表的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">单链表的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8"><span class="nav-text">销毁链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter3-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-text">Chapter3 栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">栈的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-text">顺序栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%AE%E7%A9%BA%E6%A0%88%E7%AE%97%E6%B3%95"><span class="nav-text">置空栈算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%A0%88%E7%A9%BA%E7%AE%97%E6%B3%95"><span class="nav-text">判栈空算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E6%A0%88%E7%AE%97%E6%B3%95"><span class="nav-text">入栈算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E6%A0%88%E7%AE%97%E6%B3%95"><span class="nav-text">出栈算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%A0%88"><span class="nav-text">链栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-text">伪代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B"><span class="nav-text">栈与递归过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hanoi-tower"><span class="nav-text">Hanoi tower</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">递归实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">队列的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9C%A8%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E4%B8%8A%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-text">定义在队列结构上的基本运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%98%9F%E5%88%97"><span class="nav-text">用单链表表示的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E9%98%9F%E5%88%97"><span class="nav-text">用单循环链表定义的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%85%A5%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">循环队入队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%87%BA%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">循环队出队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">构建一个空的循环队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%85%A5%E9%98%9F%E7%AE%97%E6%B3%95-1"><span class="nav-text">循环队入队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%87%BA%E9%98%9F%E7%AE%97%E6%B3%95-1"><span class="nav-text">循环队出队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%BE%AA%E7%8E%AF%E9%98%9F%E7%A9%BA%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">判循环队空队算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BD%9C%E4%B8%9A"><span class="nav-text">实验作业</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">Chapter 5 树与二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">树的结构和基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">树的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">树的基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8"><span class="nav-text">二叉树的定义与性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-text">其他函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91"><span class="nav-text">哈弗曼树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-text">树和森林</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter6-%E5%9B%BE"><span class="nav-text">Chapter6 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">图的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E5%8A%A0%E6%9D%83%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">数组+邻接矩阵&#x2F;加权邻接矩阵(顺序存储方式)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">图的遍历两种遍历方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">广度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-text">图的连通性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd-%E7%AE%97%E6%B3%95"><span class="nav-text">Floyd 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">GIn</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/libs/anime.min.js"></script>

        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
